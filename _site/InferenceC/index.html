<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>InferenceC: Bidirectional type inference (Complete) | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="InferenceC: Bidirectional type inference (Complete)" />
<meta name="author" content="Wen Kokke" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.ed.inf.ac.uk/InferenceC/" />
<meta property="og:url" content="https://plfa.ed.inf.ac.uk/InferenceC/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","author":{"@type":"Person","name":"Wen Kokke"},"@type":"WebPage","url":"https://plfa.ed.inf.ac.uk/InferenceC/","headline":"InferenceC: Bidirectional type inference (Complete)","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://plfa.ed.inf.ac.uk/feed.xml" title="Programming Language Foundations in Agda
" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">Table of Contents</a>
                <a class="page-link" href="/about/">About</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">InferenceC: Bidirectional type inference (Complete)</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="131" class="Keyword">module</a> <a id="138" href="/InferenceC/" class="Module">plfa.InferenceC</a> <a id="154" class="Keyword">where</a></pre>

<p>So far in our development, type derivations for the corresponding
term have been provided by fiat.<br />
In Chapter <a href="/Lambda/">Lambda</a>
type derivations were given separately from the term, while
in Chapter <a href="/DeBruijn/">DeBruijn</a>
the type derivation was inherently part of the term.</p>

<p>In practice, one often writes down a term with a few decorations and
applies an algorithm to <em>infer</em> the corresponding type derivation.
Indeed, this is exactly what happens in Agda: we specify the types for
top-level function declarations, and the remaining type information is
inferred from this.  The style of inference used is descended from an
algorithm called <em>bidirectional</em> type inference, which will be
presented in this chapter.</p>

<p>This chapter ties our previous developements together. We begin with
a term with some type annotations, quite close to the raw terms of
Chapter <a href="/Lambda/">Lambda</a>,
and from it we compute a term with inherent types, in the style of
Chapter <a href="/DeBruijn/">DeBruijn</a>.</p>

<h2 id="algorithms">Introduction: Inference rules as algorithms</h2>

<p>In the calculus we have considered so far, a term may have more than
one type.  For example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(ƛ x ⇒ x) ⦂ (A ⇒ A)
</code></pre></div></div>

<p>for <em>every</em> type <code class="highlighter-rouge">A</code>.  We start by considering a small language for
lambda terms where every term has a unique type.  All we need do
is decorate each abstraction term with the type of its argument.
This gives us the grammar:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L, M, N ::=                         decorated terms
  x                                   variable
  ƛ x ⦂ A ⇒ N                         abstraction (decorated)
  L · M                               application
</code></pre></div></div>

<p>Each of the associated type rules can be read as an algorithm for
type checking.  For each typing judgement, we label each position
as either an <em>input</em> or an <em>output</em>.</p>

<p>For the judgement</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ∋ x ⦂ A
</code></pre></div></div>

<p>we take the context <code class="highlighter-rouge">Γ</code> and the variable <code class="highlighter-rouge">x</code> as inputs, and the
type <code class="highlighter-rouge">A</code> as output.  Consider the rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>----------------- Z
Γ , x ⦂ A ∋ x ⦂ A

Γ ∋ y ⦂ B
----------------- S
Γ , x ⦂ A ∋ y ⦂ B
</code></pre></div></div>

<p>From the inputs we can determine which rule applies: if the last
variable in the context matches the given variable then the first
rule applies, else the second.  (For de Bruijn indices, it is even
easier: zero matches the first rule and successor the second.)
For the first rule, the output type can be read off as the last
type in the input context. For the second rule, the inputs of the
conclusion determine the inputs of the hypothesis, and the ouptut
of the hypothesis determines the output of the conclusion.</p>

<p>For the judgement</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M ⦂ A
</code></pre></div></div>

<p>we take the context <code class="highlighter-rouge">Γ</code> and term <code class="highlighter-rouge">M</code> as inputs, and the type <code class="highlighter-rouge">A</code>
as ouput. Consider the rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ∋ x ⦂ A
-----------
Γ ⊢ ` x ⦂ A

Γ , x ⦂ A ⊢ N ⦂ B
--------------------------- 
Γ ⊢ (ƛ x ⦂ A ⇒ N) ⦂ (A ⇒ B)

Γ ⊢ L ⦂ A ⇒ B
Γ ⊢ M ⦂ A′
A ≡ A′
-------------
Γ ⊢ L · M ⦂ B
</code></pre></div></div>

<p>The term input determines which rule applies: variables use the first
rule, abstractions the second, and applications the third.  In such a
situation, we say the rules are <em>syntax directed</em>.  For the
variable rule, the inputs of the conclusion determine the inputs of
the hypothesis, and the output of the hypothesis determines the output
of the conclusion.  Same for the abstraction rule — the bound variable
and argument type of the abstraction are carried into the context of
the hypothesis, and this is why we added the argument type to the
abstraction.  For the application rule, we add a third hypothesis to
check whether domain of the function matches the type of the argument;
this judgement is decidable when both types are given as inputs. The
inputs of the conclusion determine the inputs of the first two
hypotheses, the outputs of the first two hypotheses determine the
inputs of the third hypothesis, and the output of the first hypothesis
determines the output of the conclusion.</p>

<p>Converting the above to an algorithm is straightforwart, as is adding
naturals and fixpoint.  We omit the details.  Instead, we consider a
detailed description of an approach that requires less obtrusive
decoration.  The idea is to break the normal typing judgement into two
judgements, one that produces the type as an output (as above), and
another that takes it as an input.</p>

<h2 id="synthesising-and-inheriting-types">Synthesising and inheriting types</h2>

<p>In addition to the lookup judgement for variables, which will remain
as before, we now have two judgements for the type of the term.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M ↑ A
Γ ⊢ M ↓ A
</code></pre></div></div>

<p>The first of these <em>synthesises</em> the type of a term, as before,
while the second <em>inherits</em> the type.  In the first, the context
and term are inputs and the type is an output, while in the
second, all three of the context, term, and type are inputs.</p>

<p>Which terms use synthesis and which inheritance?  Our approach will be
that the main term in a <em>deconstructor</em> are typed via synthesis while
<em>constructors</em> a typed via inheritance.  For instance, the function in
an application is typed via synthesis, but an abstraction is typed via
inheritance.  The inherited type in an abstraction term serves the
same purpose as the argument type decoration of the previous section.</p>

<p>Terms that deconstruct a value of a type always have a main term
(supplying an argument of the required type) and often have
side-terms.  For application, the main term supplies the function and
the side term supplies the argument.  For case terms, the main term
supplies a natural and the side terms are the two branches.  In a
deconstructor, the main term will be typed using synthesis but the
side terms will be typed using inheritance.  As we will see, this
leads naturally to an application as a whole being typed by synthesis,
while a case term as a whole will be typed by inheritance.
Variables are naturally typed by synthesis, since we can look up
the type in the input context.  Fixed points will be naturally
typed by inheritance.</p>

<p>In order to get a syntax-directed type system we break terms into two
kinds, <code class="highlighter-rouge">Term⁺</code> and `Term⁻, which are typed by synthesis and
inheritance, respectively.  At some points, we may expect a subterm to
be typed by synthesis when in fact it is typed by inheritance, or
vice-versa, and this gives rise to two new term forms.</p>

<p>For instance, we said above that the argument of an application is
typed by inheritance and that variables are typed by synthesis, giving
a mismatch if the argument of an application is a variable.  Hence, we
need a way to treat a synthesized term as if it is inherited.  We
introduce a new term form, <code class="highlighter-rouge">M ↑</code> for this purpose.  The typing judgement
checks that the inherited and synthesised types match.</p>

<p>Similarly, we said above that the function of an application is typed
by synthesis and that abstractions are typed by inheritance, giving a
mismatch if the function of an application is a variable.  Hence, we
need a way to treat an inherited term as if it is synthesised.  We
introduce a new term form <code class="highlighter-rouge">M ↓ A</code> for this purpose.  The typing
judgement returns <code class="highlighter-rouge">A</code> as the synthesized type of the term as a whole,
as well as using it as the inherited type for <code class="highlighter-rouge">M</code>.</p>

<p>The term form <code class="highlighter-rouge">M ↓ A</code> represents the only place terms need to
be decorated with types.  It only appears when switching from
synthesis to inheritance, that is, when a term that <em>deconstructs</em>
a value of a type contains a term that <em>constructs</em> a value of a
type, in other words, a place where a β reduction will occur.
Typically, we will find that such declarations are only required
on top level declarations.</p>

<p>We can extract the grammar for terms from the above:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L⁺, M⁺, N⁺ ::=                      terms with synthesized type
  x                                   variable
  L⁺ · M-                             application
  M⁻ ↓ A                              switch to inherited

L⁻, M⁻, N⁻ ::=                      terms with inherited type
  ƛ x ⇒ N                             abstraction
  `zero                               zero
  `suc M⁻                             successor
  case L⁺ [zero⇒ M⁻ |suc x ⇒ N⁻ ]     case
  μ x ⇒ N                             fixpoint
  M ↑                                 switch to synthesized
</code></pre></div></div>

<p>With the grammar in hand, we can begin the formal development.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="8580" class="Keyword">import</a> <a id="8587" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="8625" class="Symbol">as</a> <a id="8628" class="Module">Eq</a>
<a id="8631" class="Keyword">open</a> <a id="8636" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="8639" class="Keyword">using</a> <a id="8645" class="Symbol">(</a><a id="8646" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="8649" class="Symbol">;</a> <a id="8651" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="8655" class="Symbol">;</a> <a id="8657" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#560" class="Function">sym</a><a id="8660" class="Symbol">;</a> <a id="8662" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#627" class="Function">trans</a><a id="8667" class="Symbol">;</a> <a id="8669" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1075" class="Function">cong</a><a id="8673" class="Symbol">;</a> <a id="8675" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1313" class="Function">cong₂</a><a id="8680" class="Symbol">;</a> <a id="8682" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">_≢_</a><a id="8685" class="Symbol">)</a>
<a id="8687" class="Keyword">open</a> <a id="8692" class="Keyword">import</a> <a id="8699" href="https://agda.github.io/agda-stdlib/Data.Empty.html" class="Module">Data.Empty</a> <a id="8710" class="Keyword">using</a> <a id="8716" class="Symbol">(</a><a id="8717" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a><a id="8718" class="Symbol">;</a> <a id="8720" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a><a id="8726" class="Symbol">)</a>
<a id="8728" class="Keyword">open</a> <a id="8733" class="Keyword">import</a> <a id="8740" href="https://agda.github.io/agda-stdlib/Data.List.html" class="Module">Data.List</a> <a id="8750" class="Keyword">using</a> <a id="8756" class="Symbol">(</a><a id="8757" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#80" class="Datatype">List</a><a id="8761" class="Symbol">;</a> <a id="8763" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#7506" class="InductiveConstructor">[]</a><a id="8765" class="Symbol">;</a> <a id="8767" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">_∷_</a><a id="8770" class="Symbol">;</a> <a id="8772" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#1057" class="Function">map</a><a id="8775" class="Symbol">;</a> <a id="8777" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#2376" class="Function">foldr</a><a id="8782" class="Symbol">;</a> <a id="8784" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#6317" class="Function">filter</a><a id="8790" class="Symbol">;</a> <a id="8792" href="https://agda.github.io/agda-stdlib/Data.List.Base.html#3242" class="Function">length</a><a id="8798" class="Symbol">)</a>
<a id="8800" class="Keyword">open</a> <a id="8805" class="Keyword">import</a> <a id="8812" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="8821" class="Keyword">using</a> <a id="8827" class="Symbol">(</a><a id="8828" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="8829" class="Symbol">;</a> <a id="8831" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="8835" class="Symbol">;</a> <a id="8837" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="8840" class="Symbol">;</a> <a id="8842" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="8845" class="Symbol">)</a>
<a id="8847" class="Keyword">open</a> <a id="8852" class="Keyword">import</a> <a id="8859" href="https://agda.github.io/agda-stdlib/Data.String.html" class="Module">Data.String</a> <a id="8871" class="Keyword">using</a> <a id="8877" class="Symbol">(</a><a id="8878" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a><a id="8884" class="Symbol">;</a> <a id="8886" href="https://agda.github.io/agda-stdlib/Data.String.html#1195" class="Function Operator">_≟_</a><a id="8889" class="Symbol">;</a> <a id="8891" href="https://agda.github.io/agda-stdlib/Data.String.Base.html#1101" class="Function Operator">_++_</a><a id="8895" class="Symbol">)</a>
<a id="8897" class="Keyword">open</a> <a id="8902" class="Keyword">import</a> <a id="8909" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a>
  <a id="8924" class="Keyword">using</a> <a id="8930" class="Symbol">(</a><a id="8931" href="https://agda.github.io/agda-stdlib/Data.Product.html#1329" class="Function Operator">_×_</a><a id="8934" class="Symbol">;</a> <a id="8936" href="https://agda.github.io/agda-stdlib/Data.Product.html#559" class="Field">proj₁</a><a id="8941" class="Symbol">;</a> <a id="8943" href="https://agda.github.io/agda-stdlib/Data.Product.html#573" class="Field">proj₂</a><a id="8948" class="Symbol">;</a> <a id="8950" href="https://agda.github.io/agda-stdlib/Data.Product.html#857" class="Function">∃</a><a id="8951" class="Symbol">;</a> <a id="8953" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃-syntax</a><a id="8961" class="Symbol">)</a>
  <a id="8965" class="Keyword">renaming</a> <a id="8974" class="Symbol">(</a><a id="8975" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">_,_</a> <a id="8979" class="Symbol">to</a> <a id="8982" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="8987" class="Symbol">)</a>
<a id="8989" class="Keyword">open</a> <a id="8994" class="Keyword">import</a> <a id="9001" href="https://agda.github.io/agda-stdlib/Data.Sum.html" class="Module">Data.Sum</a> <a id="9010" class="Keyword">using</a> <a id="9016" class="Symbol">(</a><a id="9017" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#414" class="Datatype Operator">_⊎_</a><a id="9020" class="Symbol">;</a> <a id="9022" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#470" class="InductiveConstructor">inj₁</a><a id="9026" class="Symbol">;</a> <a id="9028" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#495" class="InductiveConstructor">inj₂</a><a id="9032" class="Symbol">)</a>
<a id="9034" class="Keyword">open</a> <a id="9039" class="Keyword">import</a> <a id="9046" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="9055" class="Keyword">using</a> <a id="9061" class="Symbol">(</a><a id="9062" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">_∘_</a><a id="9065" class="Symbol">)</a>
<a id="9067" class="Keyword">open</a> <a id="9072" class="Keyword">import</a> <a id="9079" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="9096" class="Keyword">using</a> <a id="9102" class="Symbol">(</a><a id="9103" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="9105" class="Symbol">;</a> <a id="9107" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="9110" class="Symbol">;</a> <a id="9112" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="9115" class="Symbol">;</a> <a id="9117" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="9119" class="Symbol">)</a>
<a id="9121" class="Keyword">open</a> <a id="9126" class="Keyword">import</a> <a id="9133" href="https://agda.github.io/agda-stdlib/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="9159" class="Keyword">using</a> <a id="9165" class="Symbol">(</a><a id="9166" href="https://agda.github.io/agda-stdlib/Relation.Nullary.Negation.html#1017" class="Function">¬?</a><a id="9168" class="Symbol">)</a>

<a id="9171" class="Keyword">pattern</a> <a id="[_]"></a><a id="9179" href="/InferenceC/#9179" class="InductiveConstructor Operator">[_]</a>       <a id="9189" href="/InferenceC/#9201" class="Bound">w</a>        <a id="9198" class="Symbol">=</a>  <a id="9201" href="/InferenceC/#9201" class="Bound">w</a> <a id="9203" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9205" class="InductiveConstructor">[]</a>
<a id="9208" class="Keyword">pattern</a> <a id="[_,_]"></a><a id="9216" href="/InferenceC/#9216" class="InductiveConstructor Operator">[_,_]</a>     <a id="9226" href="/InferenceC/#9238" class="Bound">w</a> <a id="9228" href="/InferenceC/#9242" class="Bound">x</a>      <a id="9235" class="Symbol">=</a>  <a id="9238" href="/InferenceC/#9238" class="Bound">w</a> <a id="9240" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9242" href="/InferenceC/#9242" class="Bound">x</a> <a id="9244" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9246" class="InductiveConstructor">[]</a>
<a id="9249" class="Keyword">pattern</a> <a id="[_,_,_]"></a><a id="9257" href="/InferenceC/#9257" class="InductiveConstructor Operator">[_,_,_]</a>   <a id="9267" href="/InferenceC/#9279" class="Bound">w</a> <a id="9269" href="/InferenceC/#9283" class="Bound">x</a> <a id="9271" href="/InferenceC/#9287" class="Bound">y</a>    <a id="9276" class="Symbol">=</a>  <a id="9279" href="/InferenceC/#9279" class="Bound">w</a> <a id="9281" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9283" href="/InferenceC/#9283" class="Bound">x</a> <a id="9285" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9287" href="/InferenceC/#9287" class="Bound">y</a> <a id="9289" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9291" class="InductiveConstructor">[]</a>
<a id="9294" class="Keyword">pattern</a> <a id="[_,_,_,_]"></a><a id="9302" href="/InferenceC/#9302" class="InductiveConstructor Operator">[_,_,_,_]</a> <a id="9312" href="/InferenceC/#9324" class="Bound">w</a> <a id="9314" href="/InferenceC/#9328" class="Bound">x</a> <a id="9316" href="/InferenceC/#9332" class="Bound">y</a> <a id="9318" href="/InferenceC/#9336" class="Bound">z</a>  <a id="9321" class="Symbol">=</a>  <a id="9324" href="/InferenceC/#9324" class="Bound">w</a> <a id="9326" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9328" href="/InferenceC/#9328" class="Bound">x</a> <a id="9330" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9332" href="/InferenceC/#9332" class="Bound">y</a> <a id="9334" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9336" href="/InferenceC/#9336" class="Bound">z</a> <a id="9338" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#132" class="InductiveConstructor Operator">∷</a> <a id="9340" class="InductiveConstructor">[]</a></pre>

<p>Once we have a type derivation, it will be easy to construct
from it the inherently typed representation.  In order that we
can compare with our previous development, we import
module <code class="highlighter-rouge">pfla.DeBruijn</code>.</p>

<pre class="Agda"><a id="9572" class="Keyword">open</a> <a id="9577" class="Keyword">import</a> <a id="9584" href="/DeBruijn/" class="Module">plfa.DeBruijn</a> <a id="9598" class="Symbol">as</a> <a id="9601" class="Module">DB</a> <a id="9604" class="Keyword">using</a> <a id="9610" class="Symbol">(</a><a id="9611" href="/DeBruijn/#8622" class="Datatype">Type</a><a id="9615" class="Symbol">;</a> <a id="9617" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="9619" class="Symbol">;</a> <a id="9621" href="/DeBruijn/#8641" class="InductiveConstructor Operator">_⇒_</a><a id="9624" class="Symbol">)</a></pre>

<p>The phrase <code class="highlighter-rouge">as DB</code> allows us to refer to definitions
from that module as, for instance, <code class="highlighter-rouge">DB._⊢_</code>, which is
invoked as <code class="highlighter-rouge">Γ DB.⊢ A</code>, where <code class="highlighter-rouge">Γ</code> has type
<code class="highlighter-rouge">DB.Context</code> and <code class="highlighter-rouge">A</code> has type <code class="highlighter-rouge">DB.Type</code>.  We also import
<code class="highlighter-rouge">Type</code> and its constructors directly, so the latter may
also be referred to as just <code class="highlighter-rouge">Type</code>.</p>

<h2 id="syntax">Syntax</h2>

<p>First, we get all our infix declarations out of the way.
We list separately operators for judgements and terms.</p>

<pre class="Agda"><a id="10075" class="Keyword">infix</a>   <a id="10083" class="Number">4</a>  <a id="10086" href="/InferenceC/#12780" class="Datatype Operator">_∋_⦂_</a>
<a id="10092" class="Keyword">infix</a>   <a id="10100" class="Number">4</a>  <a id="10103" href="/InferenceC/#13108" class="Datatype Operator">_⊢_↑_</a>
<a id="10109" class="Keyword">infix</a>   <a id="10117" class="Number">4</a>  <a id="10120" href="/InferenceC/#13150" class="Datatype Operator">_⊢_↓_</a>
<a id="10126" class="Keyword">infixl</a>  <a id="10134" class="Number">5</a>  <a id="10137" href="/InferenceC/#10517" class="InductiveConstructor Operator">_,_⦂_</a>

<a id="10144" class="Keyword">infix</a>   <a id="10152" class="Number">5</a>  <a id="10155" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ_⇒_</a>
<a id="10160" class="Keyword">infix</a>   <a id="10168" class="Number">5</a>  <a id="10171" href="/InferenceC/#11189" class="InductiveConstructor Operator">μ_⇒_</a>
<a id="10176" class="Keyword">infix</a>   <a id="10184" class="Number">6</a>  <a id="10187" href="/InferenceC/#11237" class="InductiveConstructor Operator">_↑</a>
<a id="10190" class="Keyword">infix</a>   <a id="10198" class="Number">6</a>  <a id="10201" href="/InferenceC/#10930" class="InductiveConstructor Operator">_↓_</a>
<a id="10205" class="Keyword">infixl</a>  <a id="10213" class="Number">7</a>  <a id="10216" href="/InferenceC/#13278" class="InductiveConstructor Operator">_·_</a>
<a id="10220" class="Keyword">infix</a>   <a id="10228" class="Number">8</a>  <a id="10231" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc_</a>
<a id="10237" class="Keyword">infix</a>   <a id="10245" class="Number">9</a>  <a id="10248" href="/InferenceC/#10837" class="InductiveConstructor Operator">`_</a></pre>

<p>Identifiers are as before.</p>
<pre class="Agda"><a id="Id"></a><a id="10303" href="/InferenceC/#10303" class="Function">Id</a> <a id="10306" class="Symbol">:</a> <a id="10308" class="PrimitiveType">Set</a>
<a id="10312" href="/InferenceC/#10303" class="Function">Id</a> <a id="10315" class="Symbol">=</a> <a id="10317" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a></pre>

<p>And so are contexts. (Recall that <code class="highlighter-rouge">Type</code> is imported from
<a href="/DeBruijn/">DeBruijn</a>.)</p>
<pre class="Agda"><a id="10471" class="Keyword">data</a> <a id="Context"></a><a id="10476" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="10484" class="Symbol">:</a> <a id="10486" class="PrimitiveType">Set</a> <a id="10490" class="Keyword">where</a>
  <a id="Context.∅"></a><a id="10498" href="/InferenceC/#10498" class="InductiveConstructor">∅</a>      <a id="10505" class="Symbol">:</a> <a id="10507" href="/InferenceC/#10476" class="Datatype">Context</a>
  <a id="Context._,_⦂_"></a><a id="10517" href="/InferenceC/#10517" class="InductiveConstructor Operator">_,_⦂_</a> <a id="10523" class="Symbol">:</a> <a id="10525" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="10533" class="Symbol">→</a> <a id="10535" href="/InferenceC/#10303" class="Function">Id</a> <a id="10538" class="Symbol">→</a> <a id="10540" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="10545" class="Symbol">→</a> <a id="10547" href="/InferenceC/#10476" class="Datatype">Context</a></pre>

<p>The syntax of terms is defined by mutual recursion.
We use <code class="highlighter-rouge">Term⁺</code> and <code class="highlighter-rouge">Term⁻</code>
for terms with synthesized and inherited types, respectively.
Note the inclusion of the switching forms,
<code class="highlighter-rouge">M ↓ A</code> and <code class="highlighter-rouge">M ↑</code>.</p>
<pre class="Agda"><a id="10783" class="Keyword">data</a> <a id="Term⁺"></a><a id="10788" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="10794" class="Symbol">:</a> <a id="10796" class="PrimitiveType">Set</a>
<a id="10800" class="Keyword">data</a> <a id="Term⁻"></a><a id="10805" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="10811" class="Symbol">:</a> <a id="10813" class="PrimitiveType">Set</a>

<a id="10818" class="Keyword">data</a> <a id="10823" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="10829" class="Keyword">where</a>
  <a id="Term⁺.`_"></a><a id="10837" href="/InferenceC/#10837" class="InductiveConstructor Operator">`_</a>                        <a id="10863" class="Symbol">:</a> <a id="10865" href="/InferenceC/#10303" class="Function">Id</a> <a id="10868" class="Symbol">→</a> <a id="10870" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
  <a id="Term⁺._·_"></a><a id="10878" href="/InferenceC/#10878" class="InductiveConstructor Operator">_·_</a>                       <a id="10904" class="Symbol">:</a> <a id="10906" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="10912" class="Symbol">→</a> <a id="10914" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="10920" class="Symbol">→</a> <a id="10922" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
  <a id="Term⁺._↓_"></a><a id="10930" href="/InferenceC/#10930" class="InductiveConstructor Operator">_↓_</a>                       <a id="10956" class="Symbol">:</a> <a id="10958" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="10964" class="Symbol">→</a> <a id="10966" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="10971" class="Symbol">→</a> <a id="10973" href="/InferenceC/#10788" class="Datatype">Term⁺</a>

<a id="10980" class="Keyword">data</a> <a id="10985" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="10991" class="Keyword">where</a>
  <a id="Term⁻.ƛ_⇒_"></a><a id="10999" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ_⇒_</a>                     <a id="11024" class="Symbol">:</a> <a id="11026" href="/InferenceC/#10303" class="Function">Id</a> <a id="11029" class="Symbol">→</a> <a id="11031" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="11037" class="Symbol">→</a> <a id="11039" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
  <a id="Term⁻.`zero"></a><a id="11047" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a>                    <a id="11072" class="Symbol">:</a> <a id="11074" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
  <a id="Term⁻.`suc_"></a><a id="11082" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc_</a>                    <a id="11107" class="Symbol">:</a> <a id="11109" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="11115" class="Symbol">→</a> <a id="11117" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
  <a id="Term⁻.`case_[zero⇒_|suc_⇒_]"></a><a id="11125" href="/InferenceC/#11125" class="InductiveConstructor Operator">`case_[zero⇒_|suc_⇒_]</a>    <a id="11150" class="Symbol">:</a> <a id="11152" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="11158" class="Symbol">→</a> <a id="11160" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="11166" class="Symbol">→</a> <a id="11168" href="/InferenceC/#10303" class="Function">Id</a> <a id="11171" class="Symbol">→</a> <a id="11173" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="11179" class="Symbol">→</a> <a id="11181" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
  <a id="Term⁻.μ_⇒_"></a><a id="11189" href="/InferenceC/#11189" class="InductiveConstructor Operator">μ_⇒_</a>                     <a id="11214" class="Symbol">:</a> <a id="11216" href="/InferenceC/#10303" class="Function">Id</a> <a id="11219" class="Symbol">→</a> <a id="11221" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="11227" class="Symbol">→</a> <a id="11229" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
  <a id="Term⁻._↑"></a><a id="11237" href="/InferenceC/#11237" class="InductiveConstructor Operator">_↑</a>                       <a id="11262" class="Symbol">:</a> <a id="11264" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="11270" class="Symbol">→</a> <a id="11272" href="/InferenceC/#10805" class="Datatype">Term⁻</a></pre>
<p>The choice as to whether each term is synthesized or
inherited follows the discussion above, and can be read
off from the preceding (informal) grammar.  Main terms in
deconstructors synthesise, constructors and side terms
in deconstructors inherit.</p>

<h2 id="example-terms">Example terms</h2>

<p>We can recreate the examples from preceding chapters.
First, computing two plus two on naturals.</p>
<pre class="Agda"><a id="two"></a><a id="11667" href="/InferenceC/#11667" class="Function">two</a> <a id="11671" class="Symbol">:</a> <a id="11673" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
<a id="11679" href="/InferenceC/#11667" class="Function">two</a> <a id="11683" class="Symbol">=</a> <a id="11685" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="11690" class="Symbol">(</a><a id="11691" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="11696" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a><a id="11701" class="Symbol">)</a>

<a id="plus"></a><a id="11704" href="/InferenceC/#11704" class="Function">plus</a> <a id="11709" class="Symbol">:</a> <a id="11711" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
<a id="11717" href="/InferenceC/#11704" class="Function">plus</a> <a id="11722" class="Symbol">=</a> <a id="11724" class="Symbol">(</a><a id="11725" href="/InferenceC/#11189" class="InductiveConstructor Operator">μ</a> <a id="11727" class="String">&quot;p&quot;</a> <a id="11731" href="/InferenceC/#11189" class="InductiveConstructor Operator">⇒</a> <a id="11733" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="11735" class="String">&quot;m&quot;</a> <a id="11739" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="11741" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="11743" class="String">&quot;n&quot;</a> <a id="11747" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a>
          <a id="11759" href="/InferenceC/#11125" class="InductiveConstructor Operator">`case</a> <a id="11765" class="Symbol">(</a><a id="11766" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="11768" class="String">&quot;m&quot;</a><a id="11771" class="Symbol">)</a> <a id="11773" href="/InferenceC/#11125" class="InductiveConstructor Operator">[zero⇒</a> <a id="11780" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="11782" class="String">&quot;n&quot;</a> <a id="11786" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a>
                        <a id="11812" href="/InferenceC/#11125" class="InductiveConstructor Operator">|suc</a> <a id="11817" class="String">&quot;m&quot;</a> <a id="11821" href="/InferenceC/#11125" class="InductiveConstructor Operator">⇒</a> <a id="11823" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="11828" class="Symbol">(</a><a id="11829" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="11831" class="String">&quot;p&quot;</a> <a id="11835" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="11837" class="Symbol">(</a><a id="11838" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="11840" class="String">&quot;m&quot;</a> <a id="11844" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="11845" class="Symbol">)</a> <a id="11847" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="11849" class="Symbol">(</a><a id="11850" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="11852" class="String">&quot;n&quot;</a> <a id="11856" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="11857" class="Symbol">)</a> <a id="11859" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="11860" class="Symbol">)</a> <a id="11862" href="/InferenceC/#11125" class="InductiveConstructor Operator">]</a><a id="11863" class="Symbol">)</a>
            <a id="11877" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="11879" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="11882" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="11884" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="11887" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="11889" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>

<a id="2+2"></a><a id="11893" href="/InferenceC/#11893" class="Function">2+2</a> <a id="11897" class="Symbol">:</a> <a id="11899" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
<a id="11905" href="/InferenceC/#11893" class="Function">2+2</a> <a id="11909" class="Symbol">=</a> <a id="11911" href="/InferenceC/#11704" class="Function">plus</a> <a id="11916" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="11918" href="/InferenceC/#11667" class="Function">two</a> <a id="11922" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="11924" href="/InferenceC/#11667" class="Function">two</a></pre>
<p>The only change is to decorate with down and up arrows as required.
The only type decoration required is for <code class="highlighter-rouge">plus</code>.</p>

<p>Next, computing two plus two with Church numerals.</p>
<pre class="Agda"><a id="Ch"></a><a id="12121" href="/InferenceC/#12121" class="Function">Ch</a> <a id="12124" class="Symbol">:</a> <a id="12126" href="/DeBruijn/#8622" class="Datatype">Type</a>
<a id="12131" href="/InferenceC/#12121" class="Function">Ch</a> <a id="12134" class="Symbol">=</a> <a id="12136" class="Symbol">(</a><a id="12137" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="12140" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="12142" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="12144" class="Symbol">)</a> <a id="12146" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="12148" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="12151" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="12153" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>

<a id="twoᶜ"></a><a id="12157" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="12162" class="Symbol">:</a> <a id="12164" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
<a id="12170" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="12175" class="Symbol">=</a> <a id="12177" class="Symbol">(</a><a id="12178" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12180" class="String">&quot;s&quot;</a> <a id="12184" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12186" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12188" class="String">&quot;z&quot;</a> <a id="12192" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12194" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12196" class="String">&quot;s&quot;</a> <a id="12200" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12202" class="Symbol">(</a><a id="12203" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12205" class="String">&quot;s&quot;</a> <a id="12209" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12211" class="Symbol">(</a><a id="12212" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12214" class="String">&quot;z&quot;</a> <a id="12218" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12219" class="Symbol">)</a> <a id="12221" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12222" class="Symbol">)</a> <a id="12224" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12225" class="Symbol">)</a>

<a id="plusᶜ"></a><a id="12228" href="/InferenceC/#12228" class="Function">plusᶜ</a> <a id="12234" class="Symbol">:</a> <a id="12236" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
<a id="12242" href="/InferenceC/#12228" class="Function">plusᶜ</a> <a id="12248" class="Symbol">=</a> <a id="12250" class="Symbol">(</a><a id="12251" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12253" class="String">&quot;m&quot;</a> <a id="12257" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12259" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12261" class="String">&quot;n&quot;</a> <a id="12265" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12267" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12269" class="String">&quot;s&quot;</a> <a id="12273" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12275" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12277" class="String">&quot;z&quot;</a> <a id="12281" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a>
           <a id="12294" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12296" class="String">&quot;m&quot;</a> <a id="12300" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12302" class="Symbol">(</a><a id="12303" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12305" class="String">&quot;s&quot;</a> <a id="12309" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12310" class="Symbol">)</a> <a id="12312" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12314" class="Symbol">(</a><a id="12315" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12317" class="String">&quot;n&quot;</a> <a id="12321" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12323" class="Symbol">(</a><a id="12324" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12326" class="String">&quot;s&quot;</a> <a id="12330" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12331" class="Symbol">)</a> <a id="12333" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12335" class="Symbol">(</a><a id="12336" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12338" class="String">&quot;z&quot;</a> <a id="12342" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12343" class="Symbol">)</a> <a id="12345" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12346" class="Symbol">)</a> <a id="12348" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12349" class="Symbol">)</a>
             <a id="12364" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="12366" href="/InferenceC/#12121" class="Function">Ch</a> <a id="12369" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="12371" href="/InferenceC/#12121" class="Function">Ch</a> <a id="12374" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="12376" href="/InferenceC/#12121" class="Function">Ch</a>

<a id="sucᶜ"></a><a id="12380" href="/InferenceC/#12380" class="Function">sucᶜ</a> <a id="12385" class="Symbol">:</a> <a id="12387" href="/InferenceC/#10805" class="Datatype">Term⁻</a>
<a id="12393" href="/InferenceC/#12380" class="Function">sucᶜ</a> <a id="12398" class="Symbol">=</a> <a id="12400" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="12402" class="String">&quot;x&quot;</a> <a id="12406" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="12408" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="12413" class="Symbol">(</a><a id="12414" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="12416" class="String">&quot;x&quot;</a> <a id="12420" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="12421" class="Symbol">)</a>

<a id="2+2ᶜ"></a><a id="12424" href="/InferenceC/#12424" class="Function">2+2ᶜ</a> <a id="12429" class="Symbol">:</a> <a id="12431" href="/InferenceC/#10788" class="Datatype">Term⁺</a>
<a id="12437" href="/InferenceC/#12424" class="Function">2+2ᶜ</a> <a id="12442" class="Symbol">=</a> <a id="12444" href="/InferenceC/#12228" class="Function">plusᶜ</a> <a id="12450" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12452" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="12457" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12459" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="12464" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12466" href="/InferenceC/#12380" class="Function">sucᶜ</a> <a id="12471" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="12473" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a></pre>
<p>The only type decoration required is for <code class="highlighter-rouge">plusᶜ</code>.  One is not even
required for <code class="highlighter-rouge">sucᶜ</code>, which inherits its type as an argument of <code class="highlighter-rouge">plusᶜ</code>.</p>

<h2 id="bidirectional-type-checking">Bidirectional type checking</h2>

<p>The typing rules for variables are as in
<a href="/Lambda/">Lambda</a>.</p>
<pre class="Agda"><a id="12775" class="Keyword">data</a> <a id="_∋_⦂_"></a><a id="12780" href="/InferenceC/#12780" class="Datatype Operator">_∋_⦂_</a> <a id="12786" class="Symbol">:</a> <a id="12788" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="12796" class="Symbol">→</a> <a id="12798" href="/InferenceC/#10303" class="Function">Id</a> <a id="12801" class="Symbol">→</a> <a id="12803" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="12808" class="Symbol">→</a> <a id="12810" class="PrimitiveType">Set</a> <a id="12814" class="Keyword">where</a>

  <a id="_∋_⦂_.Z"></a><a id="12823" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="12825" class="Symbol">:</a> <a id="12827" class="Symbol">∀</a> <a id="12829" class="Symbol">{</a><a id="12830" href="/InferenceC/#12830" class="Bound">Γ</a> <a id="12832" href="/InferenceC/#12832" class="Bound">x</a> <a id="12834" href="/InferenceC/#12834" class="Bound">A</a><a id="12835" class="Symbol">}</a>
      <a id="12843" class="Comment">--------------------</a>
    <a id="12868" class="Symbol">→</a> <a id="12870" href="/InferenceC/#12830" class="Bound">Γ</a> <a id="12872" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="12874" href="/InferenceC/#12832" class="Bound">x</a> <a id="12876" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="12878" href="/InferenceC/#12834" class="Bound">A</a> <a id="12880" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="12882" href="/InferenceC/#12832" class="Bound">x</a> <a id="12884" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="12886" href="/InferenceC/#12834" class="Bound">A</a>

  <a id="_∋_⦂_.S"></a><a id="12891" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="12893" class="Symbol">:</a> <a id="12895" class="Symbol">∀</a> <a id="12897" class="Symbol">{</a><a id="12898" href="/InferenceC/#12898" class="Bound">Γ</a> <a id="12900" href="/InferenceC/#12900" class="Bound">x</a> <a id="12902" href="/InferenceC/#12902" class="Bound">y</a> <a id="12904" href="/InferenceC/#12904" class="Bound">A</a> <a id="12906" href="/InferenceC/#12906" class="Bound">B</a><a id="12907" class="Symbol">}</a>
    <a id="12913" class="Symbol">→</a> <a id="12915" href="/InferenceC/#12900" class="Bound">x</a> <a id="12917" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">≢</a> <a id="12919" href="/InferenceC/#12902" class="Bound">y</a>
    <a id="12925" class="Symbol">→</a> <a id="12927" href="/InferenceC/#12898" class="Bound">Γ</a> <a id="12929" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="12931" href="/InferenceC/#12900" class="Bound">x</a> <a id="12933" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="12935" href="/InferenceC/#12904" class="Bound">A</a>
      <a id="12943" class="Comment">-----------------</a>
    <a id="12965" class="Symbol">→</a> <a id="12967" href="/InferenceC/#12898" class="Bound">Γ</a> <a id="12969" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="12971" href="/InferenceC/#12902" class="Bound">y</a> <a id="12973" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="12975" href="/InferenceC/#12906" class="Bound">B</a> <a id="12977" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="12979" href="/InferenceC/#12900" class="Bound">x</a> <a id="12981" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="12983" href="/InferenceC/#12904" class="Bound">A</a></pre>

<p>As with syntax, the judgements for synthesizing
and inheriting types are mutually recursive.</p>
<pre class="Agda"><a id="13103" class="Keyword">data</a> <a id="_⊢_↑_"></a><a id="13108" href="/InferenceC/#13108" class="Datatype Operator">_⊢_↑_</a> <a id="13114" class="Symbol">:</a> <a id="13116" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="13124" class="Symbol">→</a> <a id="13126" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="13132" class="Symbol">→</a> <a id="13134" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="13139" class="Symbol">→</a> <a id="13141" class="PrimitiveType">Set</a>
<a id="13145" class="Keyword">data</a> <a id="_⊢_↓_"></a><a id="13150" href="/InferenceC/#13150" class="Datatype Operator">_⊢_↓_</a> <a id="13156" class="Symbol">:</a> <a id="13158" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="13166" class="Symbol">→</a> <a id="13168" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="13174" class="Symbol">→</a> <a id="13176" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="13181" class="Symbol">→</a> <a id="13183" class="PrimitiveType">Set</a>

<a id="13188" class="Keyword">data</a> <a id="13193" href="/InferenceC/#13108" class="Datatype Operator">_⊢_↑_</a> <a id="13199" class="Keyword">where</a>

  <a id="_⊢_↑_.⊢`"></a><a id="13208" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="13211" class="Symbol">:</a> <a id="13213" class="Symbol">∀</a> <a id="13215" class="Symbol">{</a><a id="13216" href="/InferenceC/#13216" class="Bound">Γ</a> <a id="13218" href="/InferenceC/#13218" class="Bound">A</a> <a id="13220" href="/InferenceC/#13220" class="Bound">x</a><a id="13221" class="Symbol">}</a>
    <a id="13227" class="Symbol">→</a> <a id="13229" href="/InferenceC/#13216" class="Bound">Γ</a> <a id="13231" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="13233" href="/InferenceC/#13220" class="Bound">x</a> <a id="13235" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="13237" href="/InferenceC/#13218" class="Bound">A</a>
      <a id="13245" class="Comment">-----------</a>
    <a id="13261" class="Symbol">→</a> <a id="13263" href="/InferenceC/#13216" class="Bound">Γ</a> <a id="13265" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13267" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="13269" href="/InferenceC/#13220" class="Bound">x</a> <a id="13271" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="13273" href="/InferenceC/#13218" class="Bound">A</a>

  <a id="_⊢_↑_._·_"></a><a id="13278" href="/InferenceC/#13278" class="InductiveConstructor Operator">_·_</a> <a id="13282" class="Symbol">:</a> <a id="13284" class="Symbol">∀</a> <a id="13286" class="Symbol">{</a><a id="13287" href="/InferenceC/#13287" class="Bound">Γ</a> <a id="13289" href="/InferenceC/#13289" class="Bound">L</a> <a id="13291" href="/InferenceC/#13291" class="Bound">M</a> <a id="13293" href="/InferenceC/#13293" class="Bound">A</a> <a id="13295" href="/InferenceC/#13295" class="Bound">B</a><a id="13296" class="Symbol">}</a>
    <a id="13302" class="Symbol">→</a> <a id="13304" href="/InferenceC/#13287" class="Bound">Γ</a> <a id="13306" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13308" href="/InferenceC/#13289" class="Bound">L</a> <a id="13310" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="13312" href="/InferenceC/#13293" class="Bound">A</a> <a id="13314" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="13316" href="/InferenceC/#13295" class="Bound">B</a>
    <a id="13322" class="Symbol">→</a> <a id="13324" href="/InferenceC/#13287" class="Bound">Γ</a> <a id="13326" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13328" href="/InferenceC/#13291" class="Bound">M</a> <a id="13330" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13332" href="/InferenceC/#13293" class="Bound">A</a>
      <a id="13340" class="Comment">-------------</a>
    <a id="13358" class="Symbol">→</a> <a id="13360" href="/InferenceC/#13287" class="Bound">Γ</a> <a id="13362" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13364" href="/InferenceC/#13289" class="Bound">L</a> <a id="13366" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="13368" href="/InferenceC/#13291" class="Bound">M</a> <a id="13370" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="13372" href="/InferenceC/#13295" class="Bound">B</a>

  <a id="_⊢_↑_.⊢↓"></a><a id="13377" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="13380" class="Symbol">:</a> <a id="13382" class="Symbol">∀</a> <a id="13384" class="Symbol">{</a><a id="13385" href="/InferenceC/#13385" class="Bound">Γ</a> <a id="13387" href="/InferenceC/#13387" class="Bound">M</a> <a id="13389" href="/InferenceC/#13389" class="Bound">A</a><a id="13390" class="Symbol">}</a>
    <a id="13396" class="Symbol">→</a> <a id="13398" href="/InferenceC/#13385" class="Bound">Γ</a> <a id="13400" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13402" href="/InferenceC/#13387" class="Bound">M</a> <a id="13404" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13406" href="/InferenceC/#13389" class="Bound">A</a>
      <a id="13414" class="Comment">---------------</a>
    <a id="13434" class="Symbol">→</a> <a id="13436" href="/InferenceC/#13385" class="Bound">Γ</a> <a id="13438" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13440" class="Symbol">(</a><a id="13441" href="/InferenceC/#13387" class="Bound">M</a> <a id="13443" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="13445" href="/InferenceC/#13389" class="Bound">A</a><a id="13446" class="Symbol">)</a> <a id="13448" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="13450" href="/InferenceC/#13389" class="Bound">A</a>

<a id="13453" class="Keyword">data</a> <a id="13458" href="/InferenceC/#13150" class="Datatype Operator">_⊢_↓_</a> <a id="13464" class="Keyword">where</a>

  <a id="_⊢_↓_.⊢ƛ"></a><a id="13473" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a> <a id="13476" class="Symbol">:</a> <a id="13478" class="Symbol">∀</a> <a id="13480" class="Symbol">{</a><a id="13481" href="/InferenceC/#13481" class="Bound">Γ</a> <a id="13483" href="/InferenceC/#13483" class="Bound">x</a> <a id="13485" href="/InferenceC/#13485" class="Bound">N</a> <a id="13487" href="/InferenceC/#13487" class="Bound">A</a> <a id="13489" href="/InferenceC/#13489" class="Bound">B</a><a id="13490" class="Symbol">}</a>
    <a id="13496" class="Symbol">→</a> <a id="13498" href="/InferenceC/#13481" class="Bound">Γ</a> <a id="13500" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="13502" href="/InferenceC/#13483" class="Bound">x</a> <a id="13504" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="13506" href="/InferenceC/#13487" class="Bound">A</a> <a id="13508" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13510" href="/InferenceC/#13485" class="Bound">N</a> <a id="13512" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13514" href="/InferenceC/#13489" class="Bound">B</a>
      <a id="13522" class="Comment">-------------------</a>
    <a id="13546" class="Symbol">→</a> <a id="13548" href="/InferenceC/#13481" class="Bound">Γ</a> <a id="13550" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13552" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="13554" href="/InferenceC/#13483" class="Bound">x</a> <a id="13556" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="13558" href="/InferenceC/#13485" class="Bound">N</a> <a id="13560" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13562" href="/InferenceC/#13487" class="Bound">A</a> <a id="13564" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="13566" href="/InferenceC/#13489" class="Bound">B</a>

  <a id="_⊢_↓_.⊢zero"></a><a id="13571" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a> <a id="13577" class="Symbol">:</a> <a id="13579" class="Symbol">∀</a> <a id="13581" class="Symbol">{</a><a id="13582" href="/InferenceC/#13582" class="Bound">Γ</a><a id="13583" class="Symbol">}</a>
      <a id="13591" class="Comment">--------------</a>
    <a id="13610" class="Symbol">→</a> <a id="13612" href="/InferenceC/#13582" class="Bound">Γ</a> <a id="13614" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13616" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a> <a id="13622" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13624" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>

  <a id="_⊢_↓_.⊢suc"></a><a id="13630" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="13635" class="Symbol">:</a> <a id="13637" class="Symbol">∀</a> <a id="13639" class="Symbol">{</a><a id="13640" href="/InferenceC/#13640" class="Bound">Γ</a> <a id="13642" href="/InferenceC/#13642" class="Bound">M</a><a id="13643" class="Symbol">}</a>
    <a id="13649" class="Symbol">→</a> <a id="13651" href="/InferenceC/#13640" class="Bound">Γ</a> <a id="13653" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13655" href="/InferenceC/#13642" class="Bound">M</a> <a id="13657" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13659" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>
      <a id="13668" class="Comment">---------------</a>
    <a id="13688" class="Symbol">→</a> <a id="13690" href="/InferenceC/#13640" class="Bound">Γ</a> <a id="13692" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13694" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="13699" href="/InferenceC/#13642" class="Bound">M</a> <a id="13701" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13703" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>

  <a id="_⊢_↓_.⊢case"></a><a id="13709" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="13715" class="Symbol">:</a> <a id="13717" class="Symbol">∀</a> <a id="13719" class="Symbol">{</a><a id="13720" href="/InferenceC/#13720" class="Bound">Γ</a> <a id="13722" href="/InferenceC/#13722" class="Bound">L</a> <a id="13724" href="/InferenceC/#13724" class="Bound">M</a> <a id="13726" href="/InferenceC/#13726" class="Bound">x</a> <a id="13728" href="/InferenceC/#13728" class="Bound">N</a> <a id="13730" href="/InferenceC/#13730" class="Bound">A</a><a id="13731" class="Symbol">}</a>
    <a id="13737" class="Symbol">→</a> <a id="13739" href="/InferenceC/#13720" class="Bound">Γ</a> <a id="13741" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13743" href="/InferenceC/#13722" class="Bound">L</a> <a id="13745" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="13747" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>
    <a id="13754" class="Symbol">→</a> <a id="13756" href="/InferenceC/#13720" class="Bound">Γ</a> <a id="13758" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13760" href="/InferenceC/#13724" class="Bound">M</a> <a id="13762" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13764" href="/InferenceC/#13730" class="Bound">A</a>
    <a id="13770" class="Symbol">→</a> <a id="13772" href="/InferenceC/#13720" class="Bound">Γ</a> <a id="13774" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="13776" href="/InferenceC/#13726" class="Bound">x</a> <a id="13778" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="13780" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="13783" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13785" href="/InferenceC/#13728" class="Bound">N</a> <a id="13787" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13789" href="/InferenceC/#13730" class="Bound">A</a>
      <a id="13797" class="Comment">-------------------------------------</a>
    <a id="13839" class="Symbol">→</a> <a id="13841" href="/InferenceC/#13720" class="Bound">Γ</a> <a id="13843" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13845" href="/InferenceC/#11125" class="InductiveConstructor Operator">`case</a> <a id="13851" href="/InferenceC/#13722" class="Bound">L</a> <a id="13853" href="/InferenceC/#11125" class="InductiveConstructor Operator">[zero⇒</a> <a id="13860" href="/InferenceC/#13724" class="Bound">M</a> <a id="13862" href="/InferenceC/#11125" class="InductiveConstructor Operator">|suc</a> <a id="13867" href="/InferenceC/#13726" class="Bound">x</a> <a id="13869" href="/InferenceC/#11125" class="InductiveConstructor Operator">⇒</a> <a id="13871" href="/InferenceC/#13728" class="Bound">N</a> <a id="13873" href="/InferenceC/#11125" class="InductiveConstructor Operator">]</a> <a id="13875" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13877" href="/InferenceC/#13730" class="Bound">A</a>

  <a id="_⊢_↓_.⊢μ"></a><a id="13882" href="/InferenceC/#13882" class="InductiveConstructor">⊢μ</a> <a id="13885" class="Symbol">:</a> <a id="13887" class="Symbol">∀</a> <a id="13889" class="Symbol">{</a><a id="13890" href="/InferenceC/#13890" class="Bound">Γ</a> <a id="13892" href="/InferenceC/#13892" class="Bound">x</a> <a id="13894" href="/InferenceC/#13894" class="Bound">N</a> <a id="13896" href="/InferenceC/#13896" class="Bound">A</a><a id="13897" class="Symbol">}</a>
    <a id="13903" class="Symbol">→</a> <a id="13905" href="/InferenceC/#13890" class="Bound">Γ</a> <a id="13907" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="13909" href="/InferenceC/#13892" class="Bound">x</a> <a id="13911" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="13913" href="/InferenceC/#13896" class="Bound">A</a> <a id="13915" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13917" href="/InferenceC/#13894" class="Bound">N</a> <a id="13919" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13921" href="/InferenceC/#13896" class="Bound">A</a>
      <a id="13929" class="Comment">-----------------</a>
    <a id="13951" class="Symbol">→</a> <a id="13953" href="/InferenceC/#13890" class="Bound">Γ</a> <a id="13955" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="13957" href="/InferenceC/#11189" class="InductiveConstructor Operator">μ</a> <a id="13959" href="/InferenceC/#13892" class="Bound">x</a> <a id="13961" href="/InferenceC/#11189" class="InductiveConstructor Operator">⇒</a> <a id="13963" href="/InferenceC/#13894" class="Bound">N</a> <a id="13965" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="13967" href="/InferenceC/#13896" class="Bound">A</a>

  <a id="_⊢_↓_.⊢↑"></a><a id="13972" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="13975" class="Symbol">:</a> <a id="13977" class="Symbol">∀</a> <a id="13979" class="Symbol">{</a><a id="13980" href="/InferenceC/#13980" class="Bound">Γ</a> <a id="13982" href="/InferenceC/#13982" class="Bound">M</a> <a id="13984" href="/InferenceC/#13984" class="Bound">A</a> <a id="13986" href="/InferenceC/#13986" class="Bound">B</a><a id="13987" class="Symbol">}</a>
    <a id="13993" class="Symbol">→</a> <a id="13995" href="/InferenceC/#13980" class="Bound">Γ</a> <a id="13997" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="13999" href="/InferenceC/#13982" class="Bound">M</a> <a id="14001" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="14003" href="/InferenceC/#13984" class="Bound">A</a>
    <a id="14009" class="Symbol">→</a> <a id="14011" href="/InferenceC/#13984" class="Bound">A</a> <a id="14013" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="14015" href="/InferenceC/#13986" class="Bound">B</a>
      <a id="14023" class="Comment">-------------</a>
    <a id="14041" class="Symbol">→</a> <a id="14043" href="/InferenceC/#13980" class="Bound">Γ</a> <a id="14045" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="14047" class="Symbol">(</a><a id="14048" href="/InferenceC/#13982" class="Bound">M</a> <a id="14050" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="14051" class="Symbol">)</a> <a id="14053" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="14055" href="/InferenceC/#13986" class="Bound">B</a></pre>
<p>We follow the same convention as
Chapter <a href="/Lambda/">Lambda</a>,
prefacing the constructor with <code class="highlighter-rouge">⊢</code> to derive the name of the
corresponding type rule.</p>

<p>The most interesting rules are those for <code class="highlighter-rouge">⊢↑</code> and <code class="highlighter-rouge">⊢↓</code>.
The former both passes the type decoration as the inherited type and returns
it as the synthesised type.  The latter takes the synthesised type and the
inherited type and confirms they are identical.  (It should remind you of
the equality test in the application rule in the first
<a href="/Inference//#algorithms">section</a>.)</p>

<h2 id="type-equality">Type equality</h2>

<p>The rule for <code class="highlighter-rouge">M ↑</code> requires the ability to decide whether two types
are equal.  It is straightforward to code.</p>
<pre class="Agda"><a id="_≟Tp_"></a><a id="14812" href="/InferenceC/#14812" class="Function Operator">_≟Tp_</a> <a id="14818" class="Symbol">:</a> <a id="14820" class="Symbol">(</a><a id="14821" href="/InferenceC/#14821" class="Bound">A</a> <a id="14823" href="/InferenceC/#14823" class="Bound">B</a> <a id="14825" class="Symbol">:</a> <a id="14827" href="/DeBruijn/#8622" class="Datatype">Type</a><a id="14831" class="Symbol">)</a> <a id="14833" class="Symbol">→</a> <a id="14835" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="14839" class="Symbol">(</a><a id="14840" href="/InferenceC/#14821" class="Bound">A</a> <a id="14842" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="14844" href="/InferenceC/#14823" class="Bound">B</a><a id="14845" class="Symbol">)</a>
<a id="14847" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>      <a id="14855" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="14859" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>              <a id="14875" class="Symbol">=</a>  <a id="14878" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="14882" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="14887" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>      <a id="14895" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="14899" class="Symbol">(</a><a id="14900" href="/InferenceC/#14900" class="Bound">A</a> <a id="14902" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="14904" href="/InferenceC/#14904" class="Bound">B</a><a id="14905" class="Symbol">)</a>         <a id="14915" class="Symbol">=</a>  <a id="14918" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="14921" class="Symbol">λ()</a>
<a id="14925" class="Symbol">(</a><a id="14926" href="/InferenceC/#14926" class="Bound">A</a> <a id="14928" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="14930" href="/InferenceC/#14930" class="Bound">B</a><a id="14931" class="Symbol">)</a> <a id="14933" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="14937" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>              <a id="14953" class="Symbol">=</a>  <a id="14956" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="14959" class="Symbol">λ()</a>
<a id="14963" class="Symbol">(</a><a id="14964" href="/InferenceC/#14964" class="Bound">A</a> <a id="14966" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="14968" href="/InferenceC/#14968" class="Bound">B</a><a id="14969" class="Symbol">)</a> <a id="14971" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="14975" class="Symbol">(</a><a id="14976" href="/InferenceC/#14976" class="Bound">A′</a> <a id="14979" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="14981" href="/InferenceC/#14981" class="Bound">B′</a><a id="14983" class="Symbol">)</a>
  <a id="14987" class="Keyword">with</a> <a id="14992" href="/InferenceC/#14964" class="Bound">A</a> <a id="14994" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="14998" href="/InferenceC/#14976" class="Bound">A′</a> <a id="15001" class="Symbol">|</a> <a id="15003" href="/InferenceC/#14968" class="Bound">B</a> <a id="15005" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="15009" href="/InferenceC/#14981" class="Bound">B′</a>
<a id="15012" class="Symbol">...</a>  <a id="15017" class="Symbol">|</a> <a id="15019" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="15022" href="/InferenceC/#15022" class="Bound">A≢</a>    <a id="15028" class="Symbol">|</a> <a id="15030" class="Symbol">_</a>         <a id="15040" class="Symbol">=</a>  <a id="15043" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="15046" class="Symbol">λ{</a><a id="15048" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="15053" class="Symbol">→</a> <a id="15055" href="/InferenceC/#15022" class="Bound">A≢</a> <a id="15058" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="15062" class="Symbol">}</a>
<a id="15064" class="Symbol">...</a>  <a id="15069" class="Symbol">|</a> <a id="15071" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15075" class="Symbol">_</a>    <a id="15080" class="Symbol">|</a> <a id="15082" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="15085" href="/InferenceC/#15085" class="Bound">B≢</a>     <a id="15092" class="Symbol">=</a>  <a id="15095" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="15098" class="Symbol">λ{</a><a id="15100" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="15105" class="Symbol">→</a> <a id="15107" href="/InferenceC/#15085" class="Bound">B≢</a> <a id="15110" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="15114" class="Symbol">}</a>
<a id="15116" class="Symbol">...</a>  <a id="15121" class="Symbol">|</a> <a id="15123" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15127" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="15132" class="Symbol">|</a> <a id="15134" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15138" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>  <a id="15144" class="Symbol">=</a>  <a id="15147" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="15151" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h2 id="type-inference-monad">Type inference monad</h2>

<p>One construct you will find in the functional programmer’s toolbox
is the <em>monad</em>, which can describe error handling, state, and
many other computational effects.  Here we introduce a monad to
manage error messages in our inferencer.</p>

<p>Type inference will either yield a value (such as a synthesized type)
or an error message (for instance, when inherited and synthesized
types differ).  An error message is given by a string.</p>
<pre class="Agda"><a id="Message"></a><a id="15633" href="/InferenceC/#15633" class="Function">Message</a> <a id="15641" class="Symbol">:</a> <a id="15643" class="PrimitiveType">Set</a>
<a id="15647" href="/InferenceC/#15633" class="Function">Message</a> <a id="15655" class="Symbol">=</a> <a id="15657" href="https://agda.github.io/agda-stdlib/Agda.Builtin.String.html#165" class="Postulate">String</a></pre>
<p>The type <code class="highlighter-rouge">I A</code> represents the result of inference, where <code class="highlighter-rouge">A</code> is an
arbitrary Agda set representing the type of the result returned;
in our case, we will return evidence for type judgments.
Note here <code class="highlighter-rouge">A</code> ranges over
Agda sets rather than types of our target lambda calculus.</p>
<pre class="Agda"><a id="15962" class="Keyword">data</a> <a id="I"></a><a id="15967" href="/InferenceC/#15967" class="Datatype">I</a> <a id="15969" class="Symbol">(</a><a id="15970" href="/InferenceC/#15970" class="Bound">A</a> <a id="15972" class="Symbol">:</a> <a id="15974" class="PrimitiveType">Set</a><a id="15977" class="Symbol">)</a> <a id="15979" class="Symbol">:</a> <a id="15981" class="PrimitiveType">Set</a> <a id="15985" class="Keyword">where</a>
  <a id="I.error⁺"></a><a id="15993" href="/InferenceC/#15993" class="InductiveConstructor">error⁺</a>  <a id="16001" class="Symbol">:</a> <a id="16003" href="/InferenceC/#15633" class="Function">Message</a> <a id="16011" class="Symbol">→</a> <a id="16013" href="/InferenceC/#10788" class="Datatype">Term⁺</a> <a id="16019" class="Symbol">→</a> <a id="16021" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="16026" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="16031" class="Symbol">→</a> <a id="16033" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16035" href="/InferenceC/#15970" class="Bound">A</a>
  <a id="I.error⁻"></a><a id="16039" href="/InferenceC/#16039" class="InductiveConstructor">error⁻</a>  <a id="16047" class="Symbol">:</a> <a id="16049" href="/InferenceC/#15633" class="Function">Message</a> <a id="16057" class="Symbol">→</a> <a id="16059" href="/InferenceC/#10805" class="Datatype">Term⁻</a> <a id="16065" class="Symbol">→</a> <a id="16067" href="https://agda.github.io/agda-stdlib/Agda.Builtin.List.html#80" class="Datatype">List</a> <a id="16072" href="/DeBruijn/#8622" class="Datatype">Type</a> <a id="16077" class="Symbol">→</a> <a id="16079" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16081" href="/InferenceC/#15970" class="Bound">A</a>
  <a id="I.return"></a><a id="16085" href="/InferenceC/#16085" class="InductiveConstructor">return</a>  <a id="16093" class="Symbol">:</a> <a id="16095" href="/InferenceC/#15970" class="Bound">A</a> <a id="16097" class="Symbol">→</a> <a id="16099" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16101" href="/InferenceC/#15970" class="Bound">A</a></pre>
<p>There are three possible constructors, two for errors and one to
return a value.  An error also takes a message, a term, and a list of
types relevant to the error; there is one variant for each sort of
term.  Return embeds values of type <code class="highlighter-rouge">A</code> into the type <code class="highlighter-rouge">I A</code>.</p>

<p>We need a way to compose functions that may return error messages,
and monads provide the required structure.
A monad is equipped with an operation, usually written <code class="highlighter-rouge">_&gt;&gt;=_</code>
and pronounced <em>bind</em>.</p>
<pre class="Agda"><a id="_&gt;&gt;=_"></a><a id="16587" href="/InferenceC/#16587" class="Function Operator">_&gt;&gt;=_</a> <a id="16593" class="Symbol">:</a> <a id="16595" class="Symbol">∀</a> <a id="16597" class="Symbol">{</a><a id="16598" href="/InferenceC/#16598" class="Bound">A</a> <a id="16600" href="/InferenceC/#16600" class="Bound">B</a> <a id="16602" class="Symbol">:</a> <a id="16604" class="PrimitiveType">Set</a><a id="16607" class="Symbol">}</a> <a id="16609" class="Symbol">→</a> <a id="16611" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16613" href="/InferenceC/#16598" class="Bound">A</a> <a id="16615" class="Symbol">→</a> <a id="16617" class="Symbol">(</a><a id="16618" href="/InferenceC/#16598" class="Bound">A</a> <a id="16620" class="Symbol">→</a> <a id="16622" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16624" href="/InferenceC/#16600" class="Bound">B</a><a id="16625" class="Symbol">)</a> <a id="16627" class="Symbol">→</a> <a id="16629" href="/InferenceC/#15967" class="Datatype">I</a> <a id="16631" href="/InferenceC/#16600" class="Bound">B</a>
<a id="16633" href="/InferenceC/#15993" class="InductiveConstructor">error⁺</a> <a id="16640" href="/InferenceC/#16640" class="Bound">msg</a> <a id="16644" href="/InferenceC/#16644" class="Bound">M</a> <a id="16646" href="/InferenceC/#16646" class="Bound">As</a> <a id="16649" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="16653" href="/InferenceC/#16653" class="Bound">k</a>  <a id="16656" class="Symbol">=</a>  <a id="16659" href="/InferenceC/#15993" class="InductiveConstructor">error⁺</a> <a id="16666" href="/InferenceC/#16640" class="Bound">msg</a> <a id="16670" href="/InferenceC/#16644" class="Bound">M</a> <a id="16672" href="/InferenceC/#16646" class="Bound">As</a>
<a id="16675" href="/InferenceC/#16039" class="InductiveConstructor">error⁻</a> <a id="16682" href="/InferenceC/#16682" class="Bound">msg</a> <a id="16686" href="/InferenceC/#16686" class="Bound">M</a> <a id="16688" href="/InferenceC/#16688" class="Bound">As</a> <a id="16691" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="16695" href="/InferenceC/#16695" class="Bound">k</a>  <a id="16698" class="Symbol">=</a>  <a id="16701" href="/InferenceC/#16039" class="InductiveConstructor">error⁻</a> <a id="16708" href="/InferenceC/#16682" class="Bound">msg</a> <a id="16712" href="/InferenceC/#16686" class="Bound">M</a> <a id="16714" href="/InferenceC/#16688" class="Bound">As</a>
<a id="16717" href="/InferenceC/#16085" class="InductiveConstructor">return</a> <a id="16724" href="/InferenceC/#16724" class="Bound">x</a>        <a id="16733" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="16737" href="/InferenceC/#16737" class="Bound">k</a>  <a id="16740" class="Symbol">=</a>  <a id="16743" href="/InferenceC/#16737" class="Bound">k</a> <a id="16745" href="/InferenceC/#16724" class="Bound">x</a></pre>
<p>If the left argument raises an error, the bind term raises
the same error.  If the right argument returns a value, the
bind term applies its left argument to that value.
There is a conflict in our conventions: here <code class="highlighter-rouge">A</code> ranges over Agda
sets, while <code class="highlighter-rouge">As</code> ranges over types of our target lambda calculus.</p>

<p>A monad is a bit like a monoid, in that it should satisfy something
akin to a left and right identity law and an associativity law.  The
role of the identity is played by <code class="highlighter-rouge">return</code>.  In our case,
all three laws are trivial to prove.</p>
<pre class="Agda"><a id="identityˡ"></a><a id="17306" href="/InferenceC/#17306" class="Function">identityˡ</a> <a id="17316" class="Symbol">:</a> <a id="17318" class="Symbol">∀</a> <a id="17320" class="Symbol">{</a><a id="17321" href="/InferenceC/#17321" class="Bound">A</a> <a id="17323" href="/InferenceC/#17323" class="Bound">B</a> <a id="17325" class="Symbol">:</a> <a id="17327" class="PrimitiveType">Set</a><a id="17330" class="Symbol">}</a> <a id="17332" class="Symbol">(</a><a id="17333" href="/InferenceC/#17333" class="Bound">x</a> <a id="17335" class="Symbol">:</a> <a id="17337" href="/InferenceC/#17321" class="Bound">A</a><a id="17338" class="Symbol">)</a> <a id="17340" class="Symbol">(</a><a id="17341" href="/InferenceC/#17341" class="Bound">k</a> <a id="17343" class="Symbol">:</a> <a id="17345" href="/InferenceC/#17321" class="Bound">A</a> <a id="17347" class="Symbol">→</a> <a id="17349" href="/InferenceC/#15967" class="Datatype">I</a> <a id="17351" href="/InferenceC/#17323" class="Bound">B</a><a id="17352" class="Symbol">)</a> <a id="17354" class="Symbol">→</a> <a id="17356" href="/InferenceC/#16085" class="InductiveConstructor">return</a> <a id="17363" href="/InferenceC/#17333" class="Bound">x</a> <a id="17365" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17369" href="/InferenceC/#17341" class="Bound">k</a> <a id="17371" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17373" href="/InferenceC/#17341" class="Bound">k</a> <a id="17375" href="/InferenceC/#17333" class="Bound">x</a>
<a id="17377" href="/InferenceC/#17306" class="Function">identityˡ</a> <a id="17387" href="/InferenceC/#17387" class="Bound">x</a> <a id="17389" href="/InferenceC/#17389" class="Bound">k</a> <a id="17391" class="Symbol">=</a> <a id="17393" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="identityʳ"></a><a id="17399" href="/InferenceC/#17399" class="Function">identityʳ</a> <a id="17409" class="Symbol">:</a> <a id="17411" class="Symbol">∀</a> <a id="17413" class="Symbol">{</a><a id="17414" href="/InferenceC/#17414" class="Bound">A</a> <a id="17416" href="/InferenceC/#17416" class="Bound">B</a> <a id="17418" class="Symbol">:</a> <a id="17420" class="PrimitiveType">Set</a><a id="17423" class="Symbol">}</a> <a id="17425" class="Symbol">(</a><a id="17426" href="/InferenceC/#17426" class="Bound">m</a> <a id="17428" class="Symbol">:</a> <a id="17430" href="/InferenceC/#15967" class="Datatype">I</a> <a id="17432" href="/InferenceC/#17414" class="Bound">A</a><a id="17433" class="Symbol">)</a> <a id="17435" class="Symbol">→</a> <a id="17437" href="/InferenceC/#17426" class="Bound">m</a> <a id="17439" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17443" class="Symbol">(λ</a> <a id="17446" href="/InferenceC/#17446" class="Bound">x</a> <a id="17448" class="Symbol">→</a> <a id="17450" href="/InferenceC/#16085" class="InductiveConstructor">return</a> <a id="17457" href="/InferenceC/#17446" class="Bound">x</a><a id="17458" class="Symbol">)</a> <a id="17460" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="17462" href="/InferenceC/#17426" class="Bound">m</a>
<a id="17464" href="/InferenceC/#17399" class="Function">identityʳ</a> <a id="17474" class="Symbol">(</a><a id="17475" href="/InferenceC/#15993" class="InductiveConstructor">error⁺</a> <a id="17482" class="Symbol">_</a> <a id="17484" class="Symbol">_</a> <a id="17486" class="Symbol">_)</a>  <a id="17490" class="Symbol">=</a>  <a id="17493" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17498" href="/InferenceC/#17399" class="Function">identityʳ</a> <a id="17508" class="Symbol">(</a><a id="17509" href="/InferenceC/#16039" class="InductiveConstructor">error⁻</a> <a id="17516" class="Symbol">_</a> <a id="17518" class="Symbol">_</a> <a id="17520" class="Symbol">_)</a>  <a id="17524" class="Symbol">=</a>  <a id="17527" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17532" href="/InferenceC/#17399" class="Function">identityʳ</a> <a id="17542" class="Symbol">(</a><a id="17543" href="/InferenceC/#16085" class="InductiveConstructor">return</a> <a id="17550" class="Symbol">_)</a>      <a id="17558" class="Symbol">=</a>  <a id="17561" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="assoc"></a><a id="17567" href="/InferenceC/#17567" class="Function">assoc</a> <a id="17573" class="Symbol">:</a> <a id="17575" class="Symbol">∀</a> <a id="17577" class="Symbol">{</a><a id="17578" href="/InferenceC/#17578" class="Bound">X</a> <a id="17580" href="/InferenceC/#17580" class="Bound">Y</a> <a id="17582" href="/InferenceC/#17582" class="Bound">Z</a> <a id="17584" class="Symbol">:</a> <a id="17586" class="PrimitiveType">Set</a><a id="17589" class="Symbol">}</a> <a id="17591" class="Symbol">(</a><a id="17592" href="/InferenceC/#17592" class="Bound">m</a> <a id="17594" class="Symbol">:</a> <a id="17596" href="/InferenceC/#15967" class="Datatype">I</a> <a id="17598" href="/InferenceC/#17578" class="Bound">X</a><a id="17599" class="Symbol">)</a> <a id="17601" class="Symbol">(</a><a id="17602" href="/InferenceC/#17602" class="Bound">k</a> <a id="17604" class="Symbol">:</a> <a id="17606" href="/InferenceC/#17578" class="Bound">X</a> <a id="17608" class="Symbol">→</a> <a id="17610" href="/InferenceC/#15967" class="Datatype">I</a> <a id="17612" href="/InferenceC/#17580" class="Bound">Y</a><a id="17613" class="Symbol">)</a> <a id="17615" class="Symbol">(</a><a id="17616" href="/InferenceC/#17616" class="Bound">h</a> <a id="17618" class="Symbol">:</a> <a id="17620" href="/InferenceC/#17580" class="Bound">Y</a> <a id="17622" class="Symbol">→</a> <a id="17624" href="/InferenceC/#15967" class="Datatype">I</a> <a id="17626" href="/InferenceC/#17582" class="Bound">Z</a><a id="17627" class="Symbol">)</a> <a id="17629" class="Symbol">→</a>
  <a id="17633" class="Symbol">(</a><a id="17634" href="/InferenceC/#17592" class="Bound">m</a> <a id="17636" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17640" class="Symbol">λ</a> <a id="17642" href="/InferenceC/#17642" class="Bound">x</a> <a id="17644" class="Symbol">→</a> <a id="17646" href="/InferenceC/#17602" class="Bound">k</a> <a id="17648" href="/InferenceC/#17642" class="Bound">x</a><a id="17649" class="Symbol">)</a> <a id="17651" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17655" class="Symbol">(λ</a> <a id="17658" href="/InferenceC/#17658" class="Bound">y</a> <a id="17660" class="Symbol">→</a> <a id="17662" href="/InferenceC/#17616" class="Bound">h</a> <a id="17664" href="/InferenceC/#17658" class="Bound">y</a><a id="17665" class="Symbol">)</a>  <a id="17668" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a>  <a id="17671" href="/InferenceC/#17592" class="Bound">m</a> <a id="17673" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17677" class="Symbol">(λ</a> <a id="17680" href="/InferenceC/#17680" class="Bound">x</a> <a id="17682" class="Symbol">→</a> <a id="17684" href="/InferenceC/#17602" class="Bound">k</a> <a id="17686" href="/InferenceC/#17680" class="Bound">x</a> <a id="17688" href="/InferenceC/#16587" class="Function Operator">&gt;&gt;=</a> <a id="17692" class="Symbol">(λ</a> <a id="17695" href="/InferenceC/#17695" class="Bound">y</a> <a id="17697" class="Symbol">→</a> <a id="17699" href="/InferenceC/#17616" class="Bound">h</a> <a id="17701" href="/InferenceC/#17695" class="Bound">y</a><a id="17702" class="Symbol">))</a>
<a id="17705" href="/InferenceC/#17567" class="Function">assoc</a> <a id="17711" class="Symbol">(</a><a id="17712" href="/InferenceC/#15993" class="InductiveConstructor">error⁺</a> <a id="17719" class="Symbol">_</a> <a id="17721" class="Symbol">_</a> <a id="17723" class="Symbol">_)</a>  <a id="17727" href="/InferenceC/#17727" class="Bound">k</a> <a id="17729" href="/InferenceC/#17729" class="Bound">h</a>  <a id="17732" class="Symbol">=</a>  <a id="17735" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17740" href="/InferenceC/#17567" class="Function">assoc</a> <a id="17746" class="Symbol">(</a><a id="17747" href="/InferenceC/#16039" class="InductiveConstructor">error⁻</a> <a id="17754" class="Symbol">_</a> <a id="17756" class="Symbol">_</a> <a id="17758" class="Symbol">_)</a>  <a id="17762" href="/InferenceC/#17762" class="Bound">k</a> <a id="17764" href="/InferenceC/#17764" class="Bound">h</a>  <a id="17767" class="Symbol">=</a>  <a id="17770" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="17775" href="/InferenceC/#17567" class="Function">assoc</a> <a id="17781" class="Symbol">(</a><a id="17782" href="/InferenceC/#16085" class="InductiveConstructor">return</a> <a id="17789" class="Symbol">_)</a>      <a id="17797" href="/InferenceC/#17797" class="Bound">k</a> <a id="17799" href="/InferenceC/#17799" class="Bound">h</a>  <a id="17802" class="Symbol">=</a>  <a id="17805" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The left-hand side of the associativity law can be abbreviated to
<code class="highlighter-rouge">(m &gt;&gt;= k) &gt;&gt;= h</code>, but it is written as above to make clear that
the law is about re-arranging parentheses.</p>

<h2 id="syntactic-sugar-for-monads">Syntactic sugar for monads</h2>

<p>Agda has built-in syntax to support the use of monads, which
translates into applications of the binding operator <code class="highlighter-rouge">_&gt;&gt;=_</code>.  Such
translation of one construct into another is referred to as <em>syntactic
sugar</em>, and we will apply it to sweeten our subsequent presentation.</p>

<p>Writing</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do x ← M
   N
</code></pre></div></div>

<p>translates to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M &gt;&gt;= λ x → N
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">x</code> is an Agda variable and <code class="highlighter-rouge">M</code> and <code class="highlighter-rouge">N</code> are terms of Agda
(rather than of our target lambda calculus).  Applying the notations
we have learned to Agda itself, we can write</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ M : I A
Γ , x : A ⊢ N : I B
-------------------
Γ ⊢ (do x ← M
        N)    : I B
</code></pre></div></div>

<p>That is, term <code class="highlighter-rouge">M</code> has type <code class="highlighter-rouge">I A</code>, variable <code class="highlighter-rouge">x</code> has type <code class="highlighter-rouge">A</code>, and term
<code class="highlighter-rouge">N</code> has type <code class="highlighter-rouge">I B</code> and may contain <code class="highlighter-rouge">x</code> as a free variable, and the
whole term has type <code class="highlighter-rouge">I B</code>.  One can read this as follows:
Evaluate <code class="highlighter-rouge">M</code>; if it fails, yield the error message; if it succeeds,
bind <code class="highlighter-rouge">x</code> to the value returned and evaluate <code class="highlighter-rouge">N</code>.</p>

<p>Similarly, writing</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do x ← L
   y ← M
   N
</code></pre></div></div>

<p>translates to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L &gt;&gt;= λ x → (M &gt;&gt;= λ y → N)
</code></pre></div></div>

<p>If <code class="highlighter-rouge">x</code> does not appear free in <code class="highlighter-rouge">N</code>, then by the associative law we
can parenthesise either way; though <code class="highlighter-rouge">x</code> may appear free in <code class="highlighter-rouge">N</code>.
We can describe the types as before:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ L : I A
Γ , x : A ⊢ M : I B
Γ , x : A , y : B ⊢ N : I C
---------------------------
Γ ⊢ (do x ← L
        y ← M
        N)    : I C
</code></pre></div></div>

<p>We can read this as: Evaluate <code class="highlighter-rouge">L</code>; if it fails, yield the error
message; if it succeeds, bind <code class="highlighter-rouge">x</code> the the value returned and
evaluate <code class="highlighter-rouge">M</code>; if it fails, yield the error message; if it
succeeds, bind <code class="highlighter-rouge">y</code> to the value returned and evaluate <code class="highlighter-rouge">N</code>.</p>

<p>Additionally, writing</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do P ← L
     where Q → M
   N
</code></pre></div></div>

<p>translates to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L &gt;&gt;= λ{ P → N ; Q → M }
</code></pre></div></div>

<p>where <code class="highlighter-rouge">P</code>, <code class="highlighter-rouge">Q</code> are Agda patterns, and <code class="highlighter-rouge">L</code>, <code class="highlighter-rouge">M</code>, <code class="highlighter-rouge">N</code> are Agda terms.
Extending our notation to allow a pattern to the left of a turnstyle, we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Γ ⊢ L : I A
Γ , P : A ⊢ N : I B
Γ , Q : A ⊢ M : I B
---------------------------
Γ ⊢ (do P ← L          
          where Q → M
        N)            : I B
</code></pre></div></div>

<p>One can read this form as follows: Evaluate <code class="highlighter-rouge">M</code>; if it fails, yield
the error message; if it succeeds, match <code class="highlighter-rouge">P</code> to the value returned and
evaluate <code class="highlighter-rouge">N</code> (which may contain variables matched by <code class="highlighter-rouge">P</code>); otherwise
match <code class="highlighter-rouge">Q</code> to the value returned and evaluate <code class="highlighter-rouge">M</code> (which may contain
variables matched by <code class="highlighter-rouge">Q</code>); one of <code class="highlighter-rouge">P</code> and <code class="highlighter-rouge">Q</code> must match.</p>

<p>The notations extend to any number of bindings or patterns. Thus,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do x₁ ← M₁
   ...
   xₙ ← Mₙ
   N
</code></pre></div></div>

<p>translates to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M₁ &gt;&gt;= (λ x₁ → ... Mₙ &gt;&gt;= (λ xₙ → N)...)
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do P ← L          
     where Q₁ → M₁
           ...    
           Qₙ → Mₙ
   N 
</code></pre></div></div>

<p>translates to</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L &gt;&gt;= λ{ P → N ; Q₁ → M₁ ; ... ; Qₙ → Mₙ }
</code></pre></div></div>

<p>We will apply this sugar to sweeten our subsequent presentation.</p>

<h2 id="some-obvious-lemmas">Some obvious lemmas</h2>

<pre class="Agda"><a id="dom≡"></a><a id="20874" href="/InferenceC/#20874" class="Function">dom≡</a> <a id="20879" class="Symbol">:</a> <a id="20881" class="Symbol">∀</a> <a id="20883" class="Symbol">{</a><a id="20884" href="/InferenceC/#20884" class="Bound">A</a> <a id="20886" href="/InferenceC/#20886" class="Bound">A′</a> <a id="20889" href="/InferenceC/#20889" class="Bound">B</a> <a id="20891" href="/InferenceC/#20891" class="Bound">B′</a><a id="20893" class="Symbol">}</a> <a id="20895" class="Symbol">→</a> <a id="20897" href="/InferenceC/#20884" class="Bound">A</a> <a id="20899" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="20901" href="/InferenceC/#20889" class="Bound">B</a> <a id="20903" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20905" href="/InferenceC/#20886" class="Bound">A′</a> <a id="20908" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="20910" href="/InferenceC/#20891" class="Bound">B′</a> <a id="20913" class="Symbol">→</a> <a id="20915" href="/InferenceC/#20884" class="Bound">A</a> <a id="20917" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20919" href="/InferenceC/#20886" class="Bound">A′</a>
<a id="20922" href="/InferenceC/#20874" class="Function">dom≡</a> <a id="20927" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="20932" class="Symbol">=</a> <a id="20934" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="rng≡"></a><a id="20940" href="/InferenceC/#20940" class="Function">rng≡</a> <a id="20945" class="Symbol">:</a> <a id="20947" class="Symbol">∀</a> <a id="20949" class="Symbol">{</a><a id="20950" href="/InferenceC/#20950" class="Bound">A</a> <a id="20952" href="/InferenceC/#20952" class="Bound">A′</a> <a id="20955" href="/InferenceC/#20955" class="Bound">B</a> <a id="20957" href="/InferenceC/#20957" class="Bound">B′</a><a id="20959" class="Symbol">}</a> <a id="20961" class="Symbol">→</a> <a id="20963" href="/InferenceC/#20950" class="Bound">A</a> <a id="20965" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="20967" href="/InferenceC/#20955" class="Bound">B</a> <a id="20969" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20971" href="/InferenceC/#20952" class="Bound">A′</a> <a id="20974" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="20976" href="/InferenceC/#20957" class="Bound">B′</a> <a id="20979" class="Symbol">→</a> <a id="20981" href="/InferenceC/#20955" class="Bound">B</a> <a id="20983" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="20985" href="/InferenceC/#20957" class="Bound">B′</a>
<a id="20988" href="/InferenceC/#20940" class="Function">rng≡</a> <a id="20993" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="20998" class="Symbol">=</a> <a id="21000" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="ℕ≢⇒"></a><a id="21006" href="/InferenceC/#21006" class="Function">ℕ≢⇒</a> <a id="21010" class="Symbol">:</a> <a id="21012" class="Symbol">∀</a> <a id="21014" class="Symbol">{</a><a id="21015" href="/InferenceC/#21015" class="Bound">A</a> <a id="21017" href="/InferenceC/#21017" class="Bound">B</a><a id="21018" class="Symbol">}</a> <a id="21020" class="Symbol">→</a> <a id="21022" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="21025" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">≢</a> <a id="21027" href="/InferenceC/#21015" class="Bound">A</a> <a id="21029" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="21031" href="/InferenceC/#21017" class="Bound">B</a>
<a id="21033" href="/InferenceC/#21006" class="Function">ℕ≢⇒</a> <a id="21037" class="Symbol">()</a></pre>

<h2 id="synthesized-types-are-unique">Synthesized types are unique</h2>

<pre class="Agda"><a id="∋uniq"></a><a id="21098" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21104" class="Symbol">:</a> <a id="21106" class="Symbol">∀</a> <a id="21108" class="Symbol">{</a><a id="21109" href="/InferenceC/#21109" class="Bound">Γ</a> <a id="21111" href="/InferenceC/#21111" class="Bound">x</a> <a id="21113" href="/InferenceC/#21113" class="Bound">A</a> <a id="21115" href="/InferenceC/#21115" class="Bound">B</a><a id="21116" class="Symbol">}</a> <a id="21118" class="Symbol">→</a> <a id="21120" href="/InferenceC/#21109" class="Bound">Γ</a> <a id="21122" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="21124" href="/InferenceC/#21111" class="Bound">x</a> <a id="21126" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="21128" href="/InferenceC/#21113" class="Bound">A</a> <a id="21130" class="Symbol">→</a> <a id="21132" href="/InferenceC/#21109" class="Bound">Γ</a> <a id="21134" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="21136" href="/InferenceC/#21111" class="Bound">x</a> <a id="21138" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="21140" href="/InferenceC/#21115" class="Bound">B</a> <a id="21142" class="Symbol">→</a> <a id="21144" href="/InferenceC/#21113" class="Bound">A</a> <a id="21146" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="21148" href="/InferenceC/#21115" class="Bound">B</a>
<a id="21150" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21156" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="21158" href="/InferenceC/#12823" class="InductiveConstructor">Z</a>                 <a id="21176" class="Symbol">=</a>  <a id="21179" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="21184" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21190" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="21192" class="Symbol">(</a><a id="21193" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="21195" href="/InferenceC/#21195" class="Bound">x≢y</a> <a id="21199" class="Symbol">_)</a>         <a id="21210" class="Symbol">=</a>  <a id="21213" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="21220" class="Symbol">(</a><a id="21221" href="/InferenceC/#21195" class="Bound">x≢y</a> <a id="21225" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="21229" class="Symbol">)</a>
<a id="21231" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21237" class="Symbol">(</a><a id="21238" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="21240" href="/InferenceC/#21240" class="Bound">x≢y</a> <a id="21244" class="Symbol">_)</a> <a id="21247" href="/InferenceC/#12823" class="InductiveConstructor">Z</a>         <a id="21257" class="Symbol">=</a>  <a id="21260" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="21267" class="Symbol">(</a><a id="21268" href="/InferenceC/#21240" class="Bound">x≢y</a> <a id="21272" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="21276" class="Symbol">)</a>
<a id="21278" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21284" class="Symbol">(</a><a id="21285" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="21287" class="Symbol">_</a> <a id="21289" href="/InferenceC/#21289" class="Bound">∋x</a><a id="21291" class="Symbol">)</a> <a id="21293" class="Symbol">(</a><a id="21294" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="21296" class="Symbol">_</a> <a id="21298" href="/InferenceC/#21298" class="Bound">∋x′</a><a id="21301" class="Symbol">)</a>  <a id="21304" class="Symbol">=</a>  <a id="21307" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21313" href="/InferenceC/#21289" class="Bound">∋x</a> <a id="21316" href="/InferenceC/#21298" class="Bound">∋x′</a>

<a id="uniq"></a><a id="21321" href="/InferenceC/#21321" class="Function">uniq</a> <a id="21326" class="Symbol">:</a> <a id="21328" class="Symbol">∀</a> <a id="21330" class="Symbol">{</a><a id="21331" href="/InferenceC/#21331" class="Bound">Γ</a> <a id="21333" href="/InferenceC/#21333" class="Bound">M</a> <a id="21335" href="/InferenceC/#21335" class="Bound">A</a> <a id="21337" href="/InferenceC/#21337" class="Bound">B</a><a id="21338" class="Symbol">}</a> <a id="21340" class="Symbol">→</a> <a id="21342" href="/InferenceC/#21331" class="Bound">Γ</a> <a id="21344" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="21346" href="/InferenceC/#21333" class="Bound">M</a> <a id="21348" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="21350" href="/InferenceC/#21335" class="Bound">A</a> <a id="21352" class="Symbol">→</a> <a id="21354" href="/InferenceC/#21331" class="Bound">Γ</a> <a id="21356" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="21358" href="/InferenceC/#21333" class="Bound">M</a> <a id="21360" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="21362" href="/InferenceC/#21337" class="Bound">B</a> <a id="21364" class="Symbol">→</a> <a id="21366" href="/InferenceC/#21335" class="Bound">A</a> <a id="21368" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="21370" href="/InferenceC/#21337" class="Bound">B</a>
<a id="21372" href="/InferenceC/#21321" class="Function">uniq</a> <a id="21377" class="Symbol">(</a><a id="21378" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="21381" href="/InferenceC/#21381" class="Bound">∋x</a><a id="21383" class="Symbol">)</a> <a id="21385" class="Symbol">(</a><a id="21386" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="21389" href="/InferenceC/#21389" class="Bound">∋x′</a><a id="21392" class="Symbol">)</a>       <a id="21400" class="Symbol">=</a>  <a id="21403" href="/InferenceC/#21098" class="Function">∋uniq</a> <a id="21409" href="/InferenceC/#21381" class="Bound">∋x</a> <a id="21412" href="/InferenceC/#21389" class="Bound">∋x′</a>
<a id="21416" href="/InferenceC/#21321" class="Function">uniq</a> <a id="21421" class="Symbol">(</a><a id="21422" href="/InferenceC/#21422" class="Bound">⊢L</a> <a id="21425" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="21427" href="/InferenceC/#21427" class="Bound">⊢M</a><a id="21429" class="Symbol">)</a> <a id="21431" class="Symbol">(</a><a id="21432" href="/InferenceC/#21432" class="Bound">⊢L′</a> <a id="21436" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="21438" href="/InferenceC/#21438" class="Bound">⊢M′</a><a id="21441" class="Symbol">)</a>  <a id="21444" class="Symbol">=</a>  <a id="21447" href="/InferenceC/#20940" class="Function">rng≡</a> <a id="21452" class="Symbol">(</a><a id="21453" href="/InferenceC/#21321" class="Function">uniq</a> <a id="21458" href="/InferenceC/#21422" class="Bound">⊢L</a> <a id="21461" href="/InferenceC/#21432" class="Bound">⊢L′</a><a id="21464" class="Symbol">)</a>
<a id="21466" href="/InferenceC/#21321" class="Function">uniq</a> <a id="21471" class="Symbol">(</a><a id="21472" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="21475" href="/InferenceC/#21475" class="Bound">⊢M</a><a id="21477" class="Symbol">)</a> <a id="21479" class="Symbol">(</a><a id="21480" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="21483" href="/InferenceC/#21483" class="Bound">⊢M′</a><a id="21486" class="Symbol">)</a>       <a id="21494" class="Symbol">=</a>  <a id="21497" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h2 id="lookup-type-of-a-variable-in-the-context">Lookup type of a variable in the context</h2>

<p>Given a context <code class="highlighter-rouge">Γ</code> and a variable <code class="highlighter-rouge">x</code>, we return a type <code class="highlighter-rouge">A</code> and
evidence that <code class="highlighter-rouge">Γ ∋ x ⦂ A</code>.  If <code class="highlighter-rouge">x</code> does not appear in <code class="highlighter-rouge">Γ</code>, then
we raise an error.</p>
<pre class="Agda"><a id="ext∋"></a><a id="21722" href="/InferenceC/#21722" class="Function">ext∋</a> <a id="21727" class="Symbol">:</a> <a id="21729" class="Symbol">∀</a> <a id="21731" class="Symbol">{</a><a id="21732" href="/InferenceC/#21732" class="Bound">Γ</a> <a id="21734" href="/InferenceC/#21734" class="Bound">B</a> <a id="21736" href="/InferenceC/#21736" class="Bound">x</a> <a id="21738" href="/InferenceC/#21738" class="Bound">y</a><a id="21739" class="Symbol">}</a> <a id="21741" class="Symbol">→</a> <a id="21743" href="/InferenceC/#21736" class="Bound">x</a> <a id="21745" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">≢</a> <a id="21747" href="/InferenceC/#21738" class="Bound">y</a> <a id="21749" class="Symbol">→</a>  <a id="21752" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="21754" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃[</a> <a id="21757" href="/InferenceC/#21757" class="Bound">A</a> <a id="21759" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">]</a><a id="21760" class="Symbol">(</a> <a id="21762" href="/InferenceC/#21732" class="Bound">Γ</a> <a id="21764" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="21766" href="/InferenceC/#21736" class="Bound">x</a> <a id="21768" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="21770" href="/InferenceC/#21757" class="Bound">A</a> <a id="21772" class="Symbol">)</a> <a id="21774" class="Symbol">→</a> <a id="21776" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="21778" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃[</a> <a id="21781" href="/InferenceC/#21781" class="Bound">A</a> <a id="21783" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">]</a><a id="21784" class="Symbol">(</a> <a id="21786" href="/InferenceC/#21732" class="Bound">Γ</a> <a id="21788" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="21790" href="/InferenceC/#21738" class="Bound">y</a> <a id="21792" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="21794" href="/InferenceC/#21734" class="Bound">B</a> <a id="21796" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="21798" href="/InferenceC/#21736" class="Bound">x</a> <a id="21800" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="21802" href="/InferenceC/#21781" class="Bound">A</a> <a id="21804" class="Symbol">)</a>
<a id="21806" href="/InferenceC/#21722" class="Function">ext∋</a> <a id="21811" href="/InferenceC/#21811" class="Bound">x≢y</a> <a id="21815" class="Symbol">_</a>  <a id="21818" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="21820" href="/InferenceC/#21820" class="Bound">A</a> <a id="21822" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="21824" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="21826" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>       <a id="21834" class="Symbol">=</a>  <a id="21837" href="/InferenceC/#21811" class="Bound">x≢y</a> <a id="21841" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="21846" href="/InferenceC/#21722" class="Function">ext∋</a> <a id="21851" class="Symbol">_</a>   <a id="21855" href="/InferenceC/#21855" class="Bound">¬∃</a> <a id="21858" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="21860" href="/InferenceC/#21860" class="Bound">A</a> <a id="21862" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="21864" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="21866" class="Symbol">_</a> <a id="21868" href="/InferenceC/#21868" class="Bound">⊢x</a> <a id="21871" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="21874" class="Symbol">=</a>  <a id="21877" href="/InferenceC/#21855" class="Bound">¬∃</a> <a id="21880" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="21882" href="/InferenceC/#21860" class="Bound">A</a> <a id="21884" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="21886" href="/InferenceC/#21868" class="Bound">⊢x</a> <a id="21889" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>

<a id="lookup"></a><a id="21892" href="/InferenceC/#21892" class="Function">lookup</a> <a id="21899" class="Symbol">:</a> <a id="21901" class="Symbol">∀</a> <a id="21903" class="Symbol">(</a><a id="21904" href="/InferenceC/#21904" class="Bound">Γ</a> <a id="21906" class="Symbol">:</a> <a id="21908" href="/InferenceC/#10476" class="Datatype">Context</a><a id="21915" class="Symbol">)</a> <a id="21917" class="Symbol">(</a><a id="21918" href="/InferenceC/#21918" class="Bound">x</a> <a id="21920" class="Symbol">:</a> <a id="21922" href="/InferenceC/#10303" class="Function">Id</a><a id="21924" class="Symbol">)</a> <a id="21926" class="Symbol">→</a> <a id="21928" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="21932" class="Symbol">(</a><a id="21933" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃[</a> <a id="21936" href="/InferenceC/#21936" class="Bound">A</a> <a id="21938" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">]</a><a id="21939" class="Symbol">(</a><a id="21940" href="/InferenceC/#21904" class="Bound">Γ</a> <a id="21942" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="21944" href="/InferenceC/#21918" class="Bound">x</a> <a id="21946" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="21948" href="/InferenceC/#21936" class="Bound">A</a><a id="21949" class="Symbol">))</a>
<a id="21952" href="/InferenceC/#21892" class="Function">lookup</a> <a id="21959" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="21961" href="/InferenceC/#21961" class="Bound">x</a>                        <a id="21986" class="Symbol">=</a>  <a id="21989" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="21992" class="Symbol">(λ</a> <a id="21995" class="Symbol">())</a>
<a id="21999" href="/InferenceC/#21892" class="Function">lookup</a> <a id="22006" class="Symbol">(</a><a id="22007" href="/InferenceC/#22007" class="Bound">Γ</a> <a id="22009" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="22011" href="/InferenceC/#22011" class="Bound">y</a> <a id="22013" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="22015" href="/InferenceC/#22015" class="Bound">B</a><a id="22016" class="Symbol">)</a> <a id="22018" href="/InferenceC/#22018" class="Bound">x</a> <a id="22020" class="Keyword">with</a> <a id="22025" href="/InferenceC/#22018" class="Bound">x</a> <a id="22027" href="https://agda.github.io/agda-stdlib/Data.String.html#1195" class="Function Operator">≟</a> <a id="22029" href="/InferenceC/#22011" class="Bound">y</a>
<a id="22031" class="Symbol">...</a> <a id="22035" class="Symbol">|</a> <a id="22037" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="22041" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>                    <a id="22065" class="Symbol">=</a>  <a id="22068" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="22072" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="22074" class="Bound">B</a> <a id="22076" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="22078" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="22080" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>
<a id="22082" class="Symbol">...</a> <a id="22086" class="Symbol">|</a> <a id="22088" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="22091" href="/InferenceC/#22091" class="Bound">x≢y</a> <a id="22095" class="Keyword">with</a> <a id="22100" href="/InferenceC/#21892" class="Function">lookup</a> <a id="22107" class="Bound">Γ</a> <a id="22109" class="Bound">x</a>
<a id="22111" class="Symbol">...</a>             <a id="22127" class="Symbol">|</a> <a id="22129" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="22133" href="/InferenceC/#22133" class="Bound">¬∃</a>          <a id="22145" class="Symbol">=</a>  <a id="22148" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="22152" class="Symbol">(</a><a id="22153" href="/InferenceC/#21722" class="Function">ext∋</a> <a id="22158" class="Bound">x≢y</a> <a id="22162" href="/InferenceC/#22133" class="Bound">¬∃</a><a id="22164" class="Symbol">)</a>
<a id="22166" class="Symbol">...</a>             <a id="22182" class="Symbol">|</a> <a id="22184" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="22188" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="22190" href="/InferenceC/#22190" class="Bound">A</a> <a id="22192" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="22194" href="/InferenceC/#22194" class="Bound">⊢x</a> <a id="22197" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="22200" class="Symbol">=</a>  <a id="22203" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="22207" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="22209" href="/InferenceC/#22190" class="Bound">A</a> <a id="22211" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="22213" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="22215" class="Bound">x≢y</a> <a id="22219" href="/InferenceC/#22194" class="Bound">⊢x</a> <a id="22222" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a></pre>
<p>There are three cases.</p>

<ul>
  <li>
    <p>If the context is empty, we raise an error.</p>
  </li>
  <li>
    <p>If the variable appears in the most recent binding, we
return its corresponding type.</p>
  </li>
  <li>
    <p>If the variable does not appear in the most recent binding,
we recurse.</p>
  </li>
</ul>

<h2 id="synthesize-and-inherit-types">Synthesize and inherit types</h2>

<p>The table has been set, the starters consumed, and we are ready
for the main course.  We have two mutually recursive functions,
one for synthesis and one for inheritance.  Synthesis is given
a context <code class="highlighter-rouge">Γ</code> and a synthesis term <code class="highlighter-rouge">M</code> and
returns a type <code class="highlighter-rouge">A</code> and evidence that <code class="highlighter-rouge">Γ ⊢ M ↑ A</code>.
Inheritance is given a context <code class="highlighter-rouge">Γ</code>, an inheritance term <code class="highlighter-rouge">M</code>,
and a type <code class="highlighter-rouge">A</code> and reuturns evidence that <code class="highlighter-rouge">Γ ⊢ M ↓ A</code>.
An error is raised when appropriate.</p>
<pre class="Agda"><a id="synthesize"></a><a id="22957" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="22968" class="Symbol">:</a> <a id="22970" class="Symbol">∀</a> <a id="22972" class="Symbol">(</a><a id="22973" href="/InferenceC/#22973" class="Bound">Γ</a> <a id="22975" class="Symbol">:</a> <a id="22977" href="/InferenceC/#10476" class="Datatype">Context</a><a id="22984" class="Symbol">)</a> <a id="22986" class="Symbol">(</a><a id="22987" href="/InferenceC/#22987" class="Bound">M</a> <a id="22989" class="Symbol">:</a> <a id="22991" href="/InferenceC/#10788" class="Datatype">Term⁺</a><a id="22996" class="Symbol">)</a> <a id="22998" class="Symbol">→</a> <a id="23000" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="23004" class="Symbol">(</a><a id="23005" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃[</a> <a id="23008" href="/InferenceC/#23008" class="Bound">A</a> <a id="23010" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">]</a><a id="23011" class="Symbol">(</a><a id="23012" href="/InferenceC/#22973" class="Bound">Γ</a> <a id="23014" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="23016" href="/InferenceC/#22987" class="Bound">M</a> <a id="23018" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="23020" href="/InferenceC/#23008" class="Bound">A</a><a id="23021" class="Symbol">))</a>
<a id="inherit"></a><a id="23024" href="/InferenceC/#23024" class="Function">inherit</a> <a id="23032" class="Symbol">:</a> <a id="23034" class="Symbol">∀</a> <a id="23036" class="Symbol">(</a><a id="23037" href="/InferenceC/#23037" class="Bound">Γ</a> <a id="23039" class="Symbol">:</a> <a id="23041" href="/InferenceC/#10476" class="Datatype">Context</a><a id="23048" class="Symbol">)</a> <a id="23050" class="Symbol">(</a><a id="23051" href="/InferenceC/#23051" class="Bound">M</a> <a id="23053" class="Symbol">:</a> <a id="23055" href="/InferenceC/#10805" class="Datatype">Term⁻</a><a id="23060" class="Symbol">)</a> <a id="23062" class="Symbol">(</a><a id="23063" href="/InferenceC/#23063" class="Bound">A</a> <a id="23065" class="Symbol">:</a> <a id="23067" href="/DeBruijn/#8622" class="Datatype">Type</a><a id="23071" class="Symbol">)</a> <a id="23073" class="Symbol">→</a> <a id="23075" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a> <a id="23079" class="Symbol">(</a><a id="23080" href="/InferenceC/#23037" class="Bound">Γ</a> <a id="23082" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="23084" href="/InferenceC/#23051" class="Bound">M</a> <a id="23086" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="23088" href="/InferenceC/#23063" class="Bound">A</a><a id="23089" class="Symbol">)</a></pre>

<p>We first consider the code for synthesis.</p>
<pre class="Agda"><a id="¬arg"></a><a id="23158" href="/InferenceC/#23158" class="Function">¬arg</a> <a id="23163" class="Symbol">:</a> <a id="23165" class="Symbol">∀</a> <a id="23167" class="Symbol">{</a><a id="23168" href="/InferenceC/#23168" class="Bound">Γ</a> <a id="23170" href="/InferenceC/#23170" class="Bound">A</a> <a id="23172" href="/InferenceC/#23172" class="Bound">B</a> <a id="23174" href="/InferenceC/#23174" class="Bound">L</a> <a id="23176" href="/InferenceC/#23176" class="Bound">M</a><a id="23177" class="Symbol">}</a> <a id="23179" class="Symbol">→</a> <a id="23181" href="/InferenceC/#23168" class="Bound">Γ</a> <a id="23183" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="23185" href="/InferenceC/#23174" class="Bound">L</a> <a id="23187" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="23189" href="/InferenceC/#23170" class="Bound">A</a> <a id="23191" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="23193" href="/InferenceC/#23172" class="Bound">B</a> <a id="23195" class="Symbol">→</a> <a id="23197" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="23199" href="/InferenceC/#23168" class="Bound">Γ</a> <a id="23201" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="23203" href="/InferenceC/#23176" class="Bound">M</a> <a id="23205" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="23207" href="/InferenceC/#23170" class="Bound">A</a> <a id="23209" class="Symbol">→</a> <a id="23211" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="23213" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">∃[</a> <a id="23216" href="/InferenceC/#23216" class="Bound">B′</a> <a id="23219" href="https://agda.github.io/agda-stdlib/Data.Product.html#918" class="Function">]</a><a id="23220" class="Symbol">(</a><a id="23221" href="/InferenceC/#23168" class="Bound">Γ</a> <a id="23223" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="23225" href="/InferenceC/#23174" class="Bound">L</a> <a id="23227" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="23229" href="/InferenceC/#23176" class="Bound">M</a> <a id="23231" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="23233" href="/InferenceC/#23216" class="Bound">B′</a><a id="23235" class="Symbol">)</a>
<a id="23237" href="/InferenceC/#23158" class="Function">¬arg</a> <a id="23242" href="/InferenceC/#23242" class="Bound">⊢L</a> <a id="23245" href="/InferenceC/#23245" class="Bound">¬⊢M</a> <a id="23249" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23251" href="/InferenceC/#23251" class="Bound">B′</a> <a id="23254" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23256" href="/InferenceC/#23256" class="Bound">⊢L′</a> <a id="23260" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="23262" href="/InferenceC/#23262" class="Bound">⊢M</a> <a id="23265" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="23267" class="Keyword">rewrite</a> <a id="23275" href="/InferenceC/#20874" class="Function">dom≡</a> <a id="23280" class="Symbol">(</a><a id="23281" href="/InferenceC/#21321" class="Function">uniq</a> <a id="23286" href="/InferenceC/#23242" class="Bound">⊢L</a> <a id="23289" href="/InferenceC/#23256" class="Bound">⊢L′</a><a id="23292" class="Symbol">)</a> <a id="23294" class="Symbol">=</a> <a id="23296" href="/InferenceC/#23245" class="Bound">¬⊢M</a> <a id="23300" href="/InferenceC/#23262" class="Bound">⊢M</a>

<a id="23304" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="23315" href="/InferenceC/#23315" class="Bound">Γ</a> <a id="23317" class="Symbol">(</a><a id="23318" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="23320" href="/InferenceC/#23320" class="Bound">x</a><a id="23321" class="Symbol">)</a> <a id="23323" class="Keyword">with</a> <a id="23328" href="/InferenceC/#21892" class="Function">lookup</a> <a id="23335" href="/InferenceC/#23315" class="Bound">Γ</a> <a id="23337" href="/InferenceC/#23320" class="Bound">x</a>
<a id="23339" class="Symbol">...</a> <a id="23343" class="Symbol">|</a> <a id="23345" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23349" href="/InferenceC/#23349" class="Bound">¬∃</a>              <a id="23365" class="Symbol">=</a>  <a id="23368" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23372" class="Symbol">(λ{</a> <a id="23376" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23378" href="/InferenceC/#23378" class="Bound">A</a> <a id="23380" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23382" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="23385" href="/InferenceC/#23385" class="Bound">∋x</a> <a id="23388" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="23390" class="Symbol">→</a> <a id="23392" href="/InferenceC/#23349" class="Bound">¬∃</a> <a id="23395" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23397" href="/InferenceC/#23378" class="Bound">A</a> <a id="23399" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23401" href="/InferenceC/#23385" class="Bound">∋x</a> <a id="23404" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="23406" class="Symbol">})</a>
<a id="23409" class="Symbol">...</a> <a id="23413" class="Symbol">|</a> <a id="23415" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23419" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23421" href="/InferenceC/#23421" class="Bound">A</a> <a id="23423" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23425" href="/InferenceC/#23425" class="Bound">∋x</a> <a id="23428" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>      <a id="23435" class="Symbol">=</a>  <a id="23438" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23442" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23444" href="/InferenceC/#23421" class="Bound">A</a> <a id="23446" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23448" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="23451" href="/InferenceC/#23425" class="Bound">∋x</a> <a id="23454" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>
<a id="23456" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="23467" href="/InferenceC/#23467" class="Bound">Γ</a> <a id="23469" class="Symbol">(</a><a id="23470" href="/InferenceC/#23470" class="Bound">L</a> <a id="23472" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="23474" href="/InferenceC/#23474" class="Bound">M</a><a id="23475" class="Symbol">)</a> <a id="23477" class="Keyword">with</a> <a id="23482" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="23493" href="/InferenceC/#23467" class="Bound">Γ</a> <a id="23495" href="/InferenceC/#23470" class="Bound">L</a>
<a id="23497" class="Symbol">...</a> <a id="23501" class="Symbol">|</a> <a id="23503" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23507" href="/InferenceC/#23507" class="Bound">¬∃</a>              <a id="23523" class="Symbol">=</a>  <a id="23526" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23530" class="Symbol">(λ{</a> <a id="23534" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23536" class="Symbol">_</a> <a id="23538" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23540" href="/InferenceC/#23540" class="Bound">⊢L</a>  <a id="23544" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="23546" class="Symbol">_</a>  <a id="23549" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="23552" class="Symbol">→</a>  <a id="23555" href="/InferenceC/#23507" class="Bound">¬∃</a> <a id="23558" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23560" class="Symbol">_</a> <a id="23562" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23564" href="/InferenceC/#23540" class="Bound">⊢L</a> <a id="23567" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="23569" class="Symbol">})</a>
<a id="23572" class="Symbol">...</a> <a id="23576" class="Symbol">|</a> <a id="23578" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23582" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23584" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="23587" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a>    <a id="23592" href="/InferenceC/#23592" class="Bound">⊢L</a> <a id="23595" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="23598" class="Symbol">=</a>  <a id="23601" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23605" class="Symbol">(λ{</a> <a id="23609" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23611" class="Symbol">_</a> <a id="23613" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23615" href="/InferenceC/#23615" class="Bound">⊢L′</a> <a id="23619" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="23621" class="Symbol">_</a>  <a id="23624" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="23627" class="Symbol">→</a>  <a id="23630" href="/InferenceC/#21006" class="Function">ℕ≢⇒</a> <a id="23634" class="Symbol">(</a><a id="23635" href="/InferenceC/#21321" class="Function">uniq</a> <a id="23640" href="/InferenceC/#23592" class="Bound">⊢L</a> <a id="23643" href="/InferenceC/#23615" class="Bound">⊢L′</a><a id="23646" class="Symbol">)</a> <a id="23648" class="Symbol">})</a>
<a id="23651" class="Symbol">...</a> <a id="23655" class="Symbol">|</a> <a id="23657" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23661" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23663" href="/InferenceC/#23663" class="Bound">A</a> <a id="23665" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="23667" href="/InferenceC/#23667" class="Bound">B</a> <a id="23669" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23671" href="/InferenceC/#23671" class="Bound">⊢L</a> <a id="23674" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="23676" class="Keyword">with</a> <a id="23681" href="/InferenceC/#23024" class="Function">inherit</a> <a id="23689" class="Bound">Γ</a> <a id="23691" class="Bound">M</a> <a id="23693" href="/InferenceC/#23663" class="Bound">A</a>
<a id="23695" class="Symbol">...</a>    <a id="23702" class="Symbol">|</a> <a id="23704" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23708" href="/InferenceC/#23708" class="Bound">¬⊢M</a>          <a id="23721" class="Symbol">=</a>  <a id="23724" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23728" class="Symbol">(</a><a id="23729" href="/InferenceC/#23158" class="Function">¬arg</a> <a id="23734" class="Bound">⊢L</a> <a id="23737" href="/InferenceC/#23708" class="Bound">¬⊢M</a><a id="23740" class="Symbol">)</a>
<a id="23742" class="Symbol">...</a>    <a id="23749" class="Symbol">|</a> <a id="23751" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23755" href="/InferenceC/#23755" class="Bound">⊢M</a>           <a id="23768" class="Symbol">=</a>  <a id="23771" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23775" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23777" class="Bound">B</a> <a id="23779" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23781" class="Bound">⊢L</a> <a id="23784" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="23786" href="/InferenceC/#23755" class="Bound">⊢M</a> <a id="23789" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  
<a id="23793" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="23804" href="/InferenceC/#23804" class="Bound">Γ</a> <a id="23806" class="Symbol">(</a><a id="23807" href="/InferenceC/#23807" class="Bound">M</a> <a id="23809" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="23811" href="/InferenceC/#23811" class="Bound">A</a><a id="23812" class="Symbol">)</a> <a id="23814" class="Keyword">with</a> <a id="23819" href="/InferenceC/#23024" class="Function">inherit</a> <a id="23827" href="/InferenceC/#23804" class="Bound">Γ</a> <a id="23829" href="/InferenceC/#23807" class="Bound">M</a> <a id="23831" href="/InferenceC/#23811" class="Bound">A</a>
<a id="23833" class="Symbol">...</a> <a id="23837" class="Symbol">|</a> <a id="23839" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23843" href="/InferenceC/#23843" class="Bound">¬⊢M</a>             <a id="23859" class="Symbol">=</a>  <a id="23862" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="23866" class="Symbol">(λ{</a> <a id="23870" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23872" class="Symbol">_</a> <a id="23874" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23876" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="23879" href="/InferenceC/#23879" class="Bound">⊢M</a> <a id="23882" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>  <a id="23885" class="Symbol">→</a>  <a id="23888" href="/InferenceC/#23843" class="Bound">¬⊢M</a> <a id="23892" href="/InferenceC/#23879" class="Bound">⊢M</a> <a id="23895" class="Symbol">})</a>
<a id="23898" class="Symbol">...</a> <a id="23902" class="Symbol">|</a> <a id="23904" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23908" href="/InferenceC/#23908" class="Bound">⊢M</a>              <a id="23924" class="Symbol">=</a>  <a id="23927" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="23931" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="23933" class="Bound">A</a> <a id="23935" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="23937" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="23940" href="/InferenceC/#23908" class="Bound">⊢M</a> <a id="23943" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a></pre>
<p>There are three cases.</p>

<ul>
  <li>
    <p>If the term is a variable, we use lookup as defined above.</p>
  </li>
  <li>
    <p>If the term is an application, we recurse to synthesize the type of
the function.  We check that the synthesied type is a function of
the form <code class="highlighter-rouge">A ⇒ B</code>.  If it is not (e.g., it is of type <code class="highlighter-rouge">`ℕ</code>), then
we report an error.  The argument is typed by inheriting <code class="highlighter-rouge">A</code>, and
type <code class="highlighter-rouge">B</code> is returned as the synthesised type of the term as a whole.</p>
  </li>
  <li>
    <p>If the term switches from synthesized to inherited, then the type
decoration <code class="highlighter-rouge">A</code> in the contained term is typed by inheriting <code class="highlighter-rouge">A</code>, and
<code class="highlighter-rouge">A</code> is also returned as the synthesized type of the term as a whole.</p>
  </li>
</ul>

<p>We next consider the code for inheritance.</p>
<pre class="Agda"><a id="¬switch"></a><a id="24658" href="/InferenceC/#24658" class="Function">¬switch</a> <a id="24666" class="Symbol">:</a> <a id="24668" class="Symbol">∀</a> <a id="24670" class="Symbol">{</a><a id="24671" href="/InferenceC/#24671" class="Bound">Γ</a> <a id="24673" href="/InferenceC/#24673" class="Bound">M</a> <a id="24675" href="/InferenceC/#24675" class="Bound">A</a> <a id="24677" href="/InferenceC/#24677" class="Bound">A′</a> <a id="24680" href="/InferenceC/#24680" class="Bound">B</a><a id="24681" class="Symbol">}</a> <a id="24683" class="Symbol">→</a> <a id="24685" class="Symbol">(</a><a id="24686" href="/InferenceC/#24671" class="Bound">Γ</a> <a id="24688" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="24690" href="/InferenceC/#24673" class="Bound">M</a> <a id="24692" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="24694" href="/InferenceC/#24675" class="Bound">A</a><a id="24695" class="Symbol">)</a> <a id="24697" class="Symbol">→</a> <a id="24699" class="Symbol">(</a><a id="24700" href="/InferenceC/#24671" class="Bound">Γ</a> <a id="24702" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="24704" href="/InferenceC/#24673" class="Bound">M</a> <a id="24706" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="24708" href="/InferenceC/#24677" class="Bound">A′</a><a id="24710" class="Symbol">)</a> <a id="24712" class="Symbol">→</a> <a id="24714" href="/InferenceC/#24675" class="Bound">A</a> <a id="24716" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">≢</a> <a id="24718" href="/InferenceC/#24680" class="Bound">B</a> <a id="24720" class="Symbol">→</a> <a id="24722" href="/InferenceC/#24677" class="Bound">A′</a> <a id="24725" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="24727" href="/InferenceC/#24680" class="Bound">B</a> <a id="24729" class="Symbol">→</a> <a id="24731" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a>
<a id="24733" href="/InferenceC/#24658" class="Function">¬switch</a> <a id="24741" href="/InferenceC/#24741" class="Bound">⊢M</a> <a id="24744" href="/InferenceC/#24744" class="Bound">⊢M′</a> <a id="24748" href="/InferenceC/#24748" class="Bound">A≢B</a> <a id="24752" href="/InferenceC/#24752" class="Bound">A′≡B</a> <a id="24757" class="Keyword">rewrite</a> <a id="24765" href="/InferenceC/#21321" class="Function">uniq</a> <a id="24770" href="/InferenceC/#24741" class="Bound">⊢M</a> <a id="24773" href="/InferenceC/#24744" class="Bound">⊢M′</a> <a id="24777" class="Symbol">=</a> <a id="24779" href="/InferenceC/#24748" class="Bound">A≢B</a> <a id="24783" href="/InferenceC/#24752" class="Bound">A′≡B</a>

<a id="24789" href="/InferenceC/#23024" class="Function">inherit</a> <a id="24797" href="/InferenceC/#24797" class="Bound">Γ</a> <a id="24799" class="Symbol">(</a><a id="24800" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="24802" href="/InferenceC/#24802" class="Bound">x</a> <a id="24804" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="24806" href="/InferenceC/#24806" class="Bound">N</a><a id="24807" class="Symbol">)</a> <a id="24809" class="Symbol">(</a><a id="24810" href="/InferenceC/#24810" class="Bound">A</a> <a id="24812" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="24814" href="/InferenceC/#24814" class="Bound">B</a><a id="24815" class="Symbol">)</a> <a id="24817" class="Keyword">with</a> <a id="24822" href="/InferenceC/#23024" class="Function">inherit</a> <a id="24830" class="Symbol">(</a><a id="24831" href="/InferenceC/#24797" class="Bound">Γ</a> <a id="24833" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="24835" href="/InferenceC/#24802" class="Bound">x</a> <a id="24837" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="24839" href="/InferenceC/#24810" class="Bound">A</a><a id="24840" class="Symbol">)</a> <a id="24842" href="/InferenceC/#24806" class="Bound">N</a> <a id="24844" href="/InferenceC/#24814" class="Bound">B</a>
<a id="24846" class="Symbol">...</a> <a id="24850" class="Symbol">|</a> <a id="24852" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="24855" href="/InferenceC/#24855" class="Bound">¬⊢N</a>                <a id="24874" class="Symbol">=</a>  <a id="24877" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24881" class="Symbol">(λ{</a> <a id="24885" class="Symbol">(</a><a id="24886" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a> <a id="24889" href="/InferenceC/#24889" class="Bound">⊢N</a><a id="24891" class="Symbol">)</a>  <a id="24894" class="Symbol">→</a>  <a id="24897" href="/InferenceC/#24855" class="Bound">¬⊢N</a> <a id="24901" href="/InferenceC/#24889" class="Bound">⊢N</a> <a id="24904" class="Symbol">})</a>
<a id="24907" class="Symbol">...</a> <a id="24911" class="Symbol">|</a> <a id="24913" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24917" href="/InferenceC/#24917" class="Bound">⊢N</a>                <a id="24935" class="Symbol">=</a>  <a id="24938" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="24942" class="Symbol">(</a><a id="24943" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a> <a id="24946" href="/InferenceC/#24917" class="Bound">⊢N</a><a id="24948" class="Symbol">)</a>
<a id="24950" href="/InferenceC/#23024" class="Function">inherit</a> <a id="24958" href="/InferenceC/#24958" class="Bound">Γ</a> <a id="24960" class="Symbol">(</a><a id="24961" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="24963" href="/InferenceC/#24963" class="Bound">x</a> <a id="24965" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="24967" href="/InferenceC/#24967" class="Bound">N</a><a id="24968" class="Symbol">)</a> <a id="24970" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>      <a id="24978" class="Symbol">=</a>  <a id="24981" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="24985" class="Symbol">(λ())</a>
<a id="24991" href="/InferenceC/#23024" class="Function">inherit</a> <a id="24999" href="/InferenceC/#24999" class="Bound">Γ</a> <a id="25001" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a> <a id="25007" class="Symbol">(</a><a id="25008" href="/InferenceC/#25008" class="Bound">A</a> <a id="25010" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="25012" href="/InferenceC/#25012" class="Bound">B</a><a id="25013" class="Symbol">)</a>     <a id="25019" class="Symbol">=</a>  <a id="25022" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="25026" class="Symbol">(λ())</a>
<a id="25032" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25040" href="/InferenceC/#25040" class="Bound">Γ</a> <a id="25042" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a> <a id="25048" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>          <a id="25060" class="Symbol">=</a>  <a id="25063" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25067" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a>
<a id="25073" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25081" href="/InferenceC/#25081" class="Bound">Γ</a> <a id="25083" class="Symbol">(</a><a id="25084" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="25089" href="/InferenceC/#25089" class="Bound">M</a><a id="25090" class="Symbol">)</a> <a id="25092" class="Symbol">(</a><a id="25093" href="/InferenceC/#25093" class="Bound">A</a> <a id="25095" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="25097" href="/InferenceC/#25097" class="Bound">B</a><a id="25098" class="Symbol">)</a>  <a id="25101" class="Symbol">=</a>  <a id="25104" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25107" class="Symbol">(λ())</a>
<a id="25113" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25121" href="/InferenceC/#25121" class="Bound">Γ</a> <a id="25123" class="Symbol">(</a><a id="25124" href="/InferenceC/#11082" class="InductiveConstructor Operator">`suc</a> <a id="25129" href="/InferenceC/#25129" class="Bound">M</a><a id="25130" class="Symbol">)</a> <a id="25132" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="25135" class="Keyword">with</a> <a id="25140" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25148" href="/InferenceC/#25121" class="Bound">Γ</a> <a id="25150" href="/InferenceC/#25129" class="Bound">M</a> <a id="25152" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>
<a id="25155" class="Symbol">...</a> <a id="25159" class="Symbol">|</a> <a id="25161" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25164" href="/InferenceC/#25164" class="Bound">¬⊢M</a>                <a id="25183" class="Symbol">=</a>  <a id="25186" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25189" class="Symbol">(λ{</a> <a id="25193" class="Symbol">(</a><a id="25194" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="25199" href="/InferenceC/#25199" class="Bound">⊢M</a><a id="25201" class="Symbol">)</a>  <a id="25204" class="Symbol">→</a>  <a id="25207" href="/InferenceC/#25164" class="Bound">¬⊢M</a> <a id="25211" href="/InferenceC/#25199" class="Bound">⊢M</a> <a id="25214" class="Symbol">})</a>
<a id="25217" class="Symbol">...</a> <a id="25221" class="Symbol">|</a> <a id="25223" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25227" href="/InferenceC/#25227" class="Bound">⊢M</a>                <a id="25245" class="Symbol">=</a>  <a id="25248" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25252" class="Symbol">(</a><a id="25253" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="25258" href="/InferenceC/#25227" class="Bound">⊢M</a><a id="25260" class="Symbol">)</a>
<a id="25262" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25270" href="/InferenceC/#25270" class="Bound">Γ</a> <a id="25272" href="/InferenceC/#11125" class="InductiveConstructor Operator">`case</a> <a id="25278" href="/InferenceC/#25278" class="Bound">L</a> <a id="25280" href="/InferenceC/#11125" class="InductiveConstructor Operator">[zero⇒</a> <a id="25287" href="/InferenceC/#25287" class="Bound">M</a> <a id="25289" href="/InferenceC/#11125" class="InductiveConstructor Operator">|suc</a> <a id="25294" href="/InferenceC/#25294" class="Bound">x</a> <a id="25296" href="/InferenceC/#11125" class="InductiveConstructor Operator">⇒</a> <a id="25298" href="/InferenceC/#25298" class="Bound">N</a> <a id="25300" href="/InferenceC/#11125" class="InductiveConstructor Operator">]</a> <a id="25302" href="/InferenceC/#25302" class="Bound">A</a> <a id="25304" class="Keyword">with</a> <a id="25309" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="25320" href="/InferenceC/#25270" class="Bound">Γ</a> <a id="25322" href="/InferenceC/#25278" class="Bound">L</a>
<a id="25324" class="Symbol">...</a> <a id="25328" class="Symbol">|</a> <a id="25330" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25333" href="/InferenceC/#25333" class="Bound">¬∃</a>                 <a id="25352" class="Symbol">=</a>  <a id="25355" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25358" class="Symbol">(λ{</a> <a id="25362" class="Symbol">(</a><a id="25363" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="25369" href="/InferenceC/#25369" class="Bound">⊢L</a>  <a id="25373" class="Symbol">_</a> <a id="25375" class="Symbol">_)</a> <a id="25378" class="Symbol">→</a> <a id="25380" href="/InferenceC/#25333" class="Bound">¬∃</a> <a id="25383" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="25385" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="25388" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="25390" href="/InferenceC/#25369" class="Bound">⊢L</a> <a id="25393" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a><a id="25394" class="Symbol">})</a>
<a id="25397" class="Symbol">...</a> <a id="25401" class="Symbol">|</a> <a id="25403" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25407" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="25409" class="Symbol">_</a> <a id="25411" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="25413" class="Symbol">_</a> <a id="25415" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="25417" href="/InferenceC/#25417" class="Bound">⊢L</a> <a id="25420" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>    <a id="25425" class="Symbol">=</a>  <a id="25428" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25431" class="Symbol">(λ{</a> <a id="25435" class="Symbol">(</a><a id="25436" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="25442" href="/InferenceC/#25442" class="Bound">⊢L′</a> <a id="25446" class="Symbol">_</a> <a id="25448" class="Symbol">_)</a> <a id="25451" class="Symbol">→</a> <a id="25453" href="/InferenceC/#21006" class="Function">ℕ≢⇒</a> <a id="25457" class="Symbol">(</a><a id="25458" href="/InferenceC/#21321" class="Function">uniq</a> <a id="25463" href="/InferenceC/#25442" class="Bound">⊢L′</a> <a id="25467" href="/InferenceC/#25417" class="Bound">⊢L</a><a id="25469" class="Symbol">)</a> <a id="25471" class="Symbol">})</a>   
<a id="25477" class="Symbol">...</a> <a id="25481" class="Symbol">|</a> <a id="25483" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25487" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="25489" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="25492" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a>    <a id="25497" href="/InferenceC/#25497" class="Bound">⊢L</a> <a id="25500" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="25502" class="Keyword">with</a> <a id="25507" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25515" class="Bound">Γ</a> <a id="25517" class="Bound">M</a> <a id="25519" class="Bound">A</a>
<a id="25521" class="Symbol">...</a>    <a id="25528" class="Symbol">|</a> <a id="25530" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25533" href="/InferenceC/#25533" class="Bound">¬⊢M</a>             <a id="25549" class="Symbol">=</a>  <a id="25552" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25555" class="Symbol">(λ{</a> <a id="25559" class="Symbol">(</a><a id="25560" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="25566" class="Symbol">_</a> <a id="25568" href="/InferenceC/#25568" class="Bound">⊢M</a> <a id="25571" class="Symbol">_)</a> <a id="25574" class="Symbol">→</a> <a id="25576" href="/InferenceC/#25533" class="Bound">¬⊢M</a> <a id="25580" href="/InferenceC/#25568" class="Bound">⊢M</a> <a id="25583" class="Symbol">})</a>
<a id="25586" class="Symbol">...</a>    <a id="25593" class="Symbol">|</a> <a id="25595" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25599" href="/InferenceC/#25599" class="Bound">⊢M</a> <a id="25602" class="Keyword">with</a> <a id="25607" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25615" class="Symbol">(</a><a id="25616" class="Bound">Γ</a> <a id="25618" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="25620" class="Bound">x</a> <a id="25622" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="25624" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="25626" class="Symbol">)</a> <a id="25628" class="Bound">N</a> <a id="25630" class="Bound">A</a>
<a id="25632" class="Symbol">...</a>       <a id="25642" class="Symbol">|</a> <a id="25644" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25647" href="/InferenceC/#25647" class="Bound">¬⊢N</a>          <a id="25660" class="Symbol">=</a>  <a id="25663" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25666" class="Symbol">(λ{</a> <a id="25670" class="Symbol">(</a><a id="25671" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="25677" class="Symbol">_</a> <a id="25679" class="Symbol">_</a> <a id="25681" href="/InferenceC/#25681" class="Bound">⊢N</a><a id="25683" class="Symbol">)</a> <a id="25685" class="Symbol">→</a> <a id="25687" href="/InferenceC/#25647" class="Bound">¬⊢N</a> <a id="25691" href="/InferenceC/#25681" class="Bound">⊢N</a> <a id="25694" class="Symbol">})</a>
<a id="25697" class="Symbol">...</a>       <a id="25707" class="Symbol">|</a> <a id="25709" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25713" href="/InferenceC/#25713" class="Bound">⊢N</a>          <a id="25725" class="Symbol">=</a>  <a id="25728" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25732" class="Symbol">(</a><a id="25733" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="25739" class="Bound">⊢L</a> <a id="25742" class="Bound">⊢M</a> <a id="25745" href="/InferenceC/#25713" class="Bound">⊢N</a><a id="25747" class="Symbol">)</a>
<a id="25749" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25757" href="/InferenceC/#25757" class="Bound">Γ</a> <a id="25759" class="Symbol">(</a><a id="25760" href="/InferenceC/#11189" class="InductiveConstructor Operator">μ</a> <a id="25762" href="/InferenceC/#25762" class="Bound">x</a> <a id="25764" href="/InferenceC/#11189" class="InductiveConstructor Operator">⇒</a> <a id="25766" href="/InferenceC/#25766" class="Bound">N</a><a id="25767" class="Symbol">)</a> <a id="25769" href="/InferenceC/#25769" class="Bound">A</a> <a id="25771" class="Keyword">with</a> <a id="25776" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25784" class="Symbol">(</a><a id="25785" href="/InferenceC/#25757" class="Bound">Γ</a> <a id="25787" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="25789" href="/InferenceC/#25762" class="Bound">x</a> <a id="25791" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="25793" href="/InferenceC/#25769" class="Bound">A</a><a id="25794" class="Symbol">)</a> <a id="25796" href="/InferenceC/#25766" class="Bound">N</a> <a id="25798" href="/InferenceC/#25769" class="Bound">A</a>
<a id="25800" class="Symbol">...</a> <a id="25804" class="Symbol">|</a> <a id="25806" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="25809" href="/InferenceC/#25809" class="Bound">¬⊢N</a>                <a id="25828" class="Symbol">=</a>  <a id="25831" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="25835" class="Symbol">(λ{</a> <a id="25839" class="Symbol">(</a><a id="25840" href="/InferenceC/#13882" class="InductiveConstructor">⊢μ</a> <a id="25843" href="/InferenceC/#25843" class="Bound">⊢N</a><a id="25845" class="Symbol">)</a> <a id="25847" class="Symbol">→</a> <a id="25849" href="/InferenceC/#25809" class="Bound">¬⊢N</a> <a id="25853" href="/InferenceC/#25843" class="Bound">⊢N</a> <a id="25856" class="Symbol">})</a>
<a id="25859" class="Symbol">...</a> <a id="25863" class="Symbol">|</a> <a id="25865" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25869" href="/InferenceC/#25869" class="Bound">⊢N</a>                <a id="25887" class="Symbol">=</a>  <a id="25890" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="25894" class="Symbol">(</a><a id="25895" href="/InferenceC/#13882" class="InductiveConstructor">⊢μ</a> <a id="25898" href="/InferenceC/#25869" class="Bound">⊢N</a><a id="25900" class="Symbol">)</a>
<a id="25902" href="/InferenceC/#23024" class="Function">inherit</a> <a id="25910" href="/InferenceC/#25910" class="Bound">Γ</a> <a id="25912" class="Symbol">(</a><a id="25913" href="/InferenceC/#25913" class="Bound">M</a> <a id="25915" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="25916" class="Symbol">)</a> <a id="25918" href="/InferenceC/#25918" class="Bound">B</a> <a id="25920" class="Keyword">with</a> <a id="25925" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="25936" href="/InferenceC/#25910" class="Bound">Γ</a> <a id="25938" href="/InferenceC/#25913" class="Bound">M</a>
<a id="25940" class="Symbol">...</a> <a id="25944" class="Symbol">|</a> <a id="25946" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="25950" href="/InferenceC/#25950" class="Bound">¬∃</a>                <a id="25968" class="Symbol">=</a>  <a id="25971" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="25975" class="Symbol">(λ{</a> <a id="25979" class="Symbol">(</a><a id="25980" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="25983" href="/InferenceC/#25983" class="Bound">⊢M</a> <a id="25986" class="Symbol">_)</a> <a id="25989" class="Symbol">→</a> <a id="25991" href="/InferenceC/#25950" class="Bound">¬∃</a> <a id="25994" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="25996" class="Symbol">_</a> <a id="25998" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="26000" href="/InferenceC/#25983" class="Bound">⊢M</a> <a id="26003" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="26005" class="Symbol">})</a>
<a id="26008" class="Symbol">...</a> <a id="26012" class="Symbol">|</a> <a id="26014" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26018" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="26020" href="/InferenceC/#26020" class="Bound">A</a> <a id="26022" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="26024" href="/InferenceC/#26024" class="Bound">⊢M</a> <a id="26027" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a> <a id="26029" class="Keyword">with</a> <a id="26034" href="/InferenceC/#26020" class="Bound">A</a> <a id="26036" href="/InferenceC/#14812" class="Function Operator">≟Tp</a> <a id="26040" class="Bound">B</a>
<a id="26042" class="Symbol">...</a>   <a id="26048" class="Symbol">|</a> <a id="26050" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26054" href="/InferenceC/#26054" class="Bound">A≢B</a>             <a id="26070" class="Symbol">=</a>  <a id="26073" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="26077" class="Symbol">(λ{</a> <a id="26081" class="Symbol">(</a><a id="26082" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="26085" href="/InferenceC/#26085" class="Bound">⊢M′</a> <a id="26089" href="/InferenceC/#26089" class="Bound">A′≡B</a><a id="26093" class="Symbol">)</a> <a id="26095" class="Symbol">→</a> <a id="26097" href="/InferenceC/#24658" class="Function">¬switch</a> <a id="26105" class="Bound">⊢M</a> <a id="26108" href="/InferenceC/#26085" class="Bound">⊢M′</a> <a id="26112" href="/InferenceC/#26054" class="Bound">A≢B</a> <a id="26116" href="/InferenceC/#26089" class="Bound">A′≡B</a> <a id="26121" class="Symbol">})</a>
<a id="26124" class="Symbol">...</a>   <a id="26130" class="Symbol">|</a> <a id="26132" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26136" href="/InferenceC/#26136" class="Bound">A≡B</a>             <a id="26152" class="Symbol">=</a>  <a id="26155" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="26159" class="Symbol">(</a><a id="26160" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="26163" class="Bound">⊢M</a> <a id="26166" href="/InferenceC/#26136" class="Bound">A≡B</a><a id="26169" class="Symbol">)</a></pre>
<p>There are nine cases.  We consider those for abstraction
and for switching from inherited to synthesized.</p>

<ul>
  <li>
    <p>If the term is an abstraction and the inherited type is of the form <code class="highlighter-rouge">A ⇒ B</code>
then we extend the context by giving the variable type <code class="highlighter-rouge">A</code> and
recuse to type the body by inheriting type <code class="highlighter-rouge">B</code>.</p>
  </li>
  <li>
    <p>If the term is an abstraction and the inherited type is not a function
(e.g., of the form <code class="highlighter-rouge">`ℕ</code>), then we report an error.</p>
  </li>
  <li>
    <p>If the term switches from inherited to synthesised, then
we synthesise the type of the contained term and compare it
to the inherited type. If they are not equal, we raise an error.</p>
  </li>
</ul>

<p>The remaining cases are similar, and their code can pretty much be
read directly from the corresponding typing rules.</p>

<h2 id="testing-the-example-terms">Testing the example terms</h2>

<p>First, we copy a function introduced ealier that makes it easy to
compute the evidence that two variable names are distinct.</p>
<pre class="Agda"><a id="_≠_"></a><a id="27090" href="/InferenceC/#27090" class="Function Operator">_≠_</a> <a id="27094" class="Symbol">:</a> <a id="27096" class="Symbol">∀</a> <a id="27098" class="Symbol">(</a><a id="27099" href="/InferenceC/#27099" class="Bound">x</a> <a id="27101" href="/InferenceC/#27101" class="Bound">y</a> <a id="27103" class="Symbol">:</a> <a id="27105" href="/InferenceC/#10303" class="Function">Id</a><a id="27107" class="Symbol">)</a> <a id="27109" class="Symbol">→</a> <a id="27111" href="/InferenceC/#27099" class="Bound">x</a> <a id="27113" href="https://agda.github.io/agda-stdlib/Relation.Binary.Core.html#5031" class="Function Operator">≢</a> <a id="27115" href="/InferenceC/#27101" class="Bound">y</a>
<a id="27117" href="/InferenceC/#27117" class="Bound">x</a> <a id="27119" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27121" href="/InferenceC/#27121" class="Bound">y</a>  <a id="27124" class="Keyword">with</a> <a id="27129" href="/InferenceC/#27117" class="Bound">x</a> <a id="27131" href="https://agda.github.io/agda-stdlib/Data.String.html#1195" class="Function Operator">≟</a> <a id="27133" href="/InferenceC/#27121" class="Bound">y</a>
<a id="27135" class="Symbol">...</a>       <a id="27145" class="Symbol">|</a> <a id="27147" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a>  <a id="27151" href="/InferenceC/#27151" class="Bound">x≢y</a>  <a id="27156" class="Symbol">=</a>  <a id="27159" href="/InferenceC/#27151" class="Bound">x≢y</a>
<a id="27163" class="Symbol">...</a>       <a id="27173" class="Symbol">|</a> <a id="27175" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27179" class="Symbol">_</a>    <a id="27184" class="Symbol">=</a>  <a id="27187" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="27194" href="/InferenceC/#27223" class="Postulate">impossible</a>
  <a id="27207" class="Keyword">where</a> <a id="27213" class="Keyword">postulate</a> <a id="27223" href="/InferenceC/#27223" class="Postulate">impossible</a> <a id="27234" class="Symbol">:</a> <a id="27236" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a></pre>

<p>Here is the result of typing two plus two on naturals.</p>
<pre class="Agda"><a id="⊢2+2"></a><a id="27318" href="/InferenceC/#27318" class="Function">⊢2+2</a> <a id="27323" class="Symbol">:</a> <a id="27325" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="27327" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="27329" href="/InferenceC/#11893" class="Function">2+2</a> <a id="27333" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="27335" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>
<a id="27338" href="/InferenceC/#27318" class="Function">⊢2+2</a> <a id="27343" class="Symbol">=</a>
  <a id="27347" class="Symbol">(</a><a id="27348" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a>
   <a id="27354" class="Symbol">(</a><a id="27355" href="/InferenceC/#13882" class="InductiveConstructor">⊢μ</a>
    <a id="27362" class="Symbol">(</a><a id="27363" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
     <a id="27371" class="Symbol">(</a><a id="27372" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
      <a id="27381" class="Symbol">(</a><a id="27382" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="27388" class="Symbol">(</a><a id="27389" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="27392" class="Symbol">(</a><a id="27393" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="27395" class="Symbol">(</a><a id="27396" class="String">&quot;m&quot;</a> <a id="27400" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27402" class="String">&quot;n&quot;</a><a id="27405" class="Symbol">)</a> <a id="27407" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="27408" class="Symbol">))</a> <a id="27411" class="Symbol">(</a><a id="27412" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="27415" class="Symbol">(</a><a id="27416" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="27419" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="27420" class="Symbol">)</a> <a id="27422" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="27426" class="Symbol">)</a>
       <a id="27435" class="Symbol">(</a><a id="27436" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a>
        <a id="27449" class="Symbol">(</a><a id="27450" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a>
         <a id="27462" class="Symbol">(</a><a id="27463" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a>
          <a id="27476" class="Symbol">(</a><a id="27477" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="27479" class="Symbol">(</a><a id="27480" class="String">&quot;p&quot;</a> <a id="27484" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27486" class="String">&quot;m&quot;</a><a id="27489" class="Symbol">)</a>
           <a id="27502" class="Symbol">(</a><a id="27503" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="27505" class="Symbol">(</a><a id="27506" class="String">&quot;p&quot;</a> <a id="27510" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27512" class="String">&quot;n&quot;</a><a id="27515" class="Symbol">)</a>
            <a id="27529" class="Symbol">(</a><a id="27530" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="27532" class="Symbol">(</a><a id="27533" class="String">&quot;p&quot;</a> <a id="27537" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27539" class="String">&quot;m&quot;</a><a id="27542" class="Symbol">)</a> <a id="27544" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="27545" class="Symbol">)))</a>
          <a id="27559" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="27561" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="27564" class="Symbol">(</a><a id="27565" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="27568" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="27569" class="Symbol">)</a> <a id="27571" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
          <a id="27586" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="27588" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="27591" class="Symbol">(</a><a id="27592" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="27595" class="Symbol">(</a><a id="27596" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="27598" class="Symbol">(</a><a id="27599" class="String">&quot;n&quot;</a> <a id="27603" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="27605" class="String">&quot;m&quot;</a><a id="27608" class="Symbol">)</a> <a id="27610" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="27611" class="Symbol">))</a> <a id="27614" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="27618" class="Symbol">)</a>
         <a id="27629" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="27633" class="Symbol">))))))</a>
   <a id="27643" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="27645" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="27650" class="Symbol">(</a><a id="27651" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="27656" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a><a id="27661" class="Symbol">)</a>
   <a id="27666" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="27668" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="27673" class="Symbol">(</a><a id="27674" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="27679" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a><a id="27684" class="Symbol">))</a></pre>
<p>We confirm that synthesis on the relevant term returns
natural as the type and the above derivation.</p>
<pre class="Agda"><a id="27812" href="/InferenceC/#27812" class="Function">_</a> <a id="27814" class="Symbol">:</a> <a id="27816" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="27827" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="27829" href="/InferenceC/#11893" class="Function">2+2</a> <a id="27833" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="27835" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="27839" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="27841" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="27844" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="27846" href="/InferenceC/#27318" class="Function">⊢2+2</a> <a id="27851" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>
<a id="27853" class="Symbol">_</a> <a id="27855" class="Symbol">=</a> <a id="27857" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Indeed, the above derivation was computed by evaluating the
term on the left, and editing.  The only editing required is to
replace Agda’s representation of the evidence that two strings are
unequal (which it can print not read) by equivalent calls to <code class="highlighter-rouge">≠</code>.</p>

<p>Here is the result of typing two plus two with Church numerals.</p>
<pre class="Agda"><a id="⊢2+2ᶜ"></a><a id="28208" href="/InferenceC/#28208" class="Function">⊢2+2ᶜ</a> <a id="28214" class="Symbol">:</a> <a id="28216" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="28218" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="28220" href="/InferenceC/#12424" class="Function">2+2ᶜ</a> <a id="28225" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="28227" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a>
<a id="28230" href="/InferenceC/#28208" class="Function">⊢2+2ᶜ</a> <a id="28236" class="Symbol">=</a>
  <a id="28240" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a>
  <a id="28245" class="Symbol">(</a><a id="28246" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
   <a id="28252" class="Symbol">(</a><a id="28253" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
    <a id="28260" class="Symbol">(</a><a id="28261" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
     <a id="28269" class="Symbol">(</a><a id="28270" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
      <a id="28279" class="Symbol">(</a><a id="28280" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a>
       <a id="28290" class="Symbol">(</a><a id="28291" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a>
        <a id="28302" class="Symbol">(</a><a id="28303" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28305" class="Symbol">(</a><a id="28306" class="String">&quot;m&quot;</a> <a id="28310" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28312" class="String">&quot;z&quot;</a><a id="28315" class="Symbol">)</a>
         <a id="28326" class="Symbol">(</a><a id="28327" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28329" class="Symbol">(</a><a id="28330" class="String">&quot;m&quot;</a> <a id="28334" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28336" class="String">&quot;s&quot;</a><a id="28339" class="Symbol">)</a>
          <a id="28351" class="Symbol">(</a><a id="28352" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28354" class="Symbol">(</a><a id="28355" class="String">&quot;m&quot;</a> <a id="28359" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28361" class="String">&quot;n&quot;</a><a id="28364" class="Symbol">)</a> <a id="28366" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28367" class="Symbol">)))</a>
        <a id="28379" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28381" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28384" class="Symbol">(</a><a id="28385" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28388" class="Symbol">(</a><a id="28389" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28391" class="Symbol">(</a><a id="28392" class="String">&quot;s&quot;</a> <a id="28396" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28398" class="String">&quot;z&quot;</a><a id="28401" class="Symbol">)</a> <a id="28403" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28404" class="Symbol">))</a> <a id="28407" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
        <a id="28420" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a>
        <a id="28430" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a>
        <a id="28441" class="Symbol">(</a><a id="28442" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a>
         <a id="28454" class="Symbol">(</a><a id="28455" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28457" class="Symbol">(</a><a id="28458" class="String">&quot;n&quot;</a> <a id="28462" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28464" class="String">&quot;z&quot;</a><a id="28467" class="Symbol">)</a>
          <a id="28479" class="Symbol">(</a><a id="28480" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28482" class="Symbol">(</a><a id="28483" class="String">&quot;n&quot;</a> <a id="28487" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28489" class="String">&quot;s&quot;</a><a id="28492" class="Symbol">)</a> <a id="28494" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28495" class="Symbol">))</a>
         <a id="28507" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28509" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28512" class="Symbol">(</a><a id="28513" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28516" class="Symbol">(</a><a id="28517" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28519" class="Symbol">(</a><a id="28520" class="String">&quot;s&quot;</a> <a id="28524" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28526" class="String">&quot;z&quot;</a><a id="28529" class="Symbol">)</a> <a id="28531" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28532" class="Symbol">))</a> <a id="28535" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
         <a id="28549" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28551" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28554" class="Symbol">(</a><a id="28555" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28558" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28559" class="Symbol">)</a> <a id="28561" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28565" class="Symbol">)</a>
        <a id="28575" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28579" class="Symbol">)</a>
       <a id="28588" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28592" class="Symbol">)))))</a>
  <a id="28600" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a>
  <a id="28604" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
  <a id="28609" class="Symbol">(</a><a id="28610" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
   <a id="28616" class="Symbol">(</a><a id="28617" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a>
    <a id="28624" class="Symbol">(</a><a id="28625" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28628" class="Symbol">(</a><a id="28629" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28631" class="Symbol">(</a><a id="28632" class="String">&quot;s&quot;</a> <a id="28636" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28638" class="String">&quot;z&quot;</a><a id="28641" class="Symbol">)</a> <a id="28643" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28644" class="Symbol">)</a> <a id="28646" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a>
     <a id="28653" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28656" class="Symbol">(</a><a id="28657" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28660" class="Symbol">(</a><a id="28661" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28663" class="Symbol">(</a><a id="28664" class="String">&quot;s&quot;</a> <a id="28668" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28670" class="String">&quot;z&quot;</a><a id="28673" class="Symbol">)</a> <a id="28675" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28676" class="Symbol">)</a> <a id="28678" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28680" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28683" class="Symbol">(</a><a id="28684" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28687" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28688" class="Symbol">)</a> <a id="28690" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28694" class="Symbol">)</a>
     <a id="28701" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28705" class="Symbol">)</a>
    <a id="28711" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28715" class="Symbol">))</a>
  <a id="28720" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a>
  <a id="28724" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
  <a id="28729" class="Symbol">(</a><a id="28730" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a>
   <a id="28736" class="Symbol">(</a><a id="28737" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a>
    <a id="28744" class="Symbol">(</a><a id="28745" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28748" class="Symbol">(</a><a id="28749" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28751" class="Symbol">(</a><a id="28752" class="String">&quot;s&quot;</a> <a id="28756" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28758" class="String">&quot;z&quot;</a><a id="28761" class="Symbol">)</a> <a id="28763" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28764" class="Symbol">)</a> <a id="28766" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a>
     <a id="28773" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28776" class="Symbol">(</a><a id="28777" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28780" class="Symbol">(</a><a id="28781" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="28783" class="Symbol">(</a><a id="28784" class="String">&quot;s&quot;</a> <a id="28788" href="/InferenceC/#27090" class="Function Operator">≠</a> <a id="28790" class="String">&quot;z&quot;</a><a id="28793" class="Symbol">)</a> <a id="28795" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28796" class="Symbol">)</a> <a id="28798" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28800" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28803" class="Symbol">(</a><a id="28804" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28807" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28808" class="Symbol">)</a> <a id="28810" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28814" class="Symbol">)</a>
     <a id="28821" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28825" class="Symbol">)</a>
    <a id="28831" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28835" class="Symbol">))</a>
  <a id="28840" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28842" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a> <a id="28845" class="Symbol">(</a><a id="28846" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="28851" class="Symbol">(</a><a id="28852" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="28855" class="Symbol">(</a><a id="28856" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="28859" href="/InferenceC/#12823" class="InductiveConstructor">Z</a><a id="28860" class="Symbol">)</a> <a id="28862" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="28866" class="Symbol">))</a>
  <a id="28871" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="28873" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a></pre>
<p>We confirm that synthesis on the relevant term returns
natural as the type and the above derivation.</p>
<pre class="Agda"><a id="29004" href="/InferenceC/#29004" class="Function">_</a> <a id="29006" class="Symbol">:</a> <a id="29008" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29019" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29021" href="/InferenceC/#12424" class="Function">2+2ᶜ</a> <a id="29026" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29028" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a> <a id="29032" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨</a> <a id="29034" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="29037" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">,</a> <a id="29039" href="/InferenceC/#28208" class="Function">⊢2+2ᶜ</a> <a id="29045" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟩</a>
<a id="29047" class="Symbol">_</a> <a id="29049" class="Symbol">=</a> <a id="29051" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Again, the above derivation was computed by evaluating the
term on the left, and editing.</p>

<h2 id="testing-the-error-cases">Testing the error cases</h2>

<p>It is important not just to check that code works as intended,
but also that it fails as intended.
<!--
Here is one test case to
exercise each of the possible error messages.
--></p>
<pre class="Agda"><a id="29378" href="/InferenceC/#29378" class="Function">_</a> <a id="29380" class="Symbol">:</a> <a id="29382" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29393" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29395" class="Symbol">((</a><a id="29397" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="29399" class="String">&quot;x&quot;</a> <a id="29403" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="29405" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="29407" class="String">&quot;y&quot;</a> <a id="29411" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="29412" class="Symbol">)</a> <a id="29414" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="29416" class="Symbol">(</a><a id="29417" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="29420" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="29422" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="29424" class="Symbol">))</a> <a id="29427" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29429" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="29432" class="Symbol">_</a>
  <a id="29436" class="Comment">-- error⁺ &quot;variable not bound&quot; (` &quot;y&quot;) []</a>
<a id="29478" class="Symbol">_</a> <a id="29480" class="Symbol">=</a> <a id="29482" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="29488" href="/InferenceC/#29488" class="Function">_</a> <a id="29490" class="Symbol">:</a> <a id="29492" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29503" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29505" class="Symbol">((</a><a id="29507" href="/InferenceC/#11667" class="Function">two</a> <a id="29511" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="29513" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="29515" class="Symbol">)</a> <a id="29517" href="/InferenceC/#10878" class="InductiveConstructor Operator">·</a> <a id="29519" href="/InferenceC/#11667" class="Function">two</a><a id="29522" class="Symbol">)</a> <a id="29524" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29526" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="29529" class="Symbol">_</a>
  <a id="29533" class="Comment">-- error⁺ &quot;must apply function&quot;</a>
  <a id="29567" class="Comment">--   ((`suc (`suc `zero) ↓ `ℕ) · `suc (`suc `zero)) []</a>
<a id="29622" class="Symbol">_</a> <a id="29624" class="Symbol">=</a> <a id="29626" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="29632" href="/InferenceC/#29632" class="Function">_</a> <a id="29634" class="Symbol">:</a> <a id="29636" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29647" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29649" class="Symbol">(</a><a id="29650" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="29655" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="29657" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="29659" class="Symbol">)</a> <a id="29661" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29663" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="29666" class="Symbol">_</a>
  <a id="29670" class="Comment">-- error⁻ &quot;lambda cannot be of type natural&quot;</a>
  <a id="29717" class="Comment">--   (ƛ &quot;s&quot; ⇒ (ƛ &quot;z&quot; ⇒ ` &quot;s&quot; · (` &quot;s&quot; · (` &quot;z&quot; ↑) ↑) ↑)) []</a>
<a id="29777" class="Symbol">_</a> <a id="29779" class="Symbol">=</a> <a id="29781" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="29787" href="/InferenceC/#29787" class="Function">_</a> <a id="29789" class="Symbol">:</a> <a id="29791" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29802" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29804" class="Symbol">(</a><a id="29805" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a> <a id="29811" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="29813" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="29816" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="29818" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="29820" class="Symbol">)</a> <a id="29822" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29824" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="29827" class="Symbol">_</a>
  <a id="29831" class="Comment">-- error⁻ &quot;zero cannot be function&quot; `zero [ `ℕ ⇒ `ℕ ]</a>
<a id="29885" class="Symbol">_</a> <a id="29887" class="Symbol">=</a> <a id="29889" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="29895" href="/InferenceC/#29895" class="Function">_</a> <a id="29897" class="Symbol">:</a> <a id="29899" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="29910" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="29912" class="Symbol">(</a><a id="29913" href="/InferenceC/#11667" class="Function">two</a> <a id="29917" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="29919" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="29922" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="29924" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="29926" class="Symbol">)</a> <a id="29928" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="29930" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="29933" class="Symbol">_</a>
  <a id="29937" class="Comment">-- error⁻ &quot;suc cannot be function&quot; (`suc (`suc `zero)) [ `ℕ ⇒ `ℕ ]</a>
<a id="30004" class="Symbol">_</a> <a id="30006" class="Symbol">=</a> <a id="30008" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="30014" href="/InferenceC/#30014" class="Function">_</a> <a id="30016" class="Symbol">:</a> <a id="30018" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="30029" href="/InferenceC/#10498" class="InductiveConstructor">∅</a>
      <a id="30037" class="Symbol">((</a><a id="30039" href="/InferenceC/#11125" class="InductiveConstructor Operator">`case</a> <a id="30045" class="Symbol">(</a><a id="30046" href="/InferenceC/#12157" class="Function">twoᶜ</a> <a id="30051" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="30053" href="/InferenceC/#12121" class="Function">Ch</a><a id="30055" class="Symbol">)</a> <a id="30057" href="/InferenceC/#11125" class="InductiveConstructor Operator">[zero⇒</a> <a id="30064" href="/InferenceC/#11047" class="InductiveConstructor">`zero</a> <a id="30070" href="/InferenceC/#11125" class="InductiveConstructor Operator">|suc</a> <a id="30075" class="String">&quot;x&quot;</a> <a id="30079" href="/InferenceC/#11125" class="InductiveConstructor Operator">⇒</a> <a id="30081" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="30083" class="String">&quot;x&quot;</a> <a id="30087" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a> <a id="30089" href="/InferenceC/#11125" class="InductiveConstructor Operator">]</a> <a id="30091" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="30093" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="30095" class="Symbol">)</a> <a id="30097" class="Symbol">)</a> <a id="30099" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="30101" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="30104" class="Symbol">_</a>
  <a id="30108" class="Comment">-- error⁻ &quot;cannot case on function&quot;</a>
  <a id="30146" class="Comment">--   `case (ƛ &quot;s&quot; ⇒ (ƛ &quot;z&quot; ⇒ ` &quot;s&quot; · (` &quot;s&quot; · (` &quot;z&quot; ↑) ↑) ↑))</a>
  <a id="30211" class="Comment">--         ↓ (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ [zero⇒ `zero |suc &quot;x&quot; ⇒ ` &quot;x&quot; ↑ ]</a>
  <a id="30280" class="Comment">--   [ (`ℕ ⇒ `ℕ) ⇒ `ℕ ⇒ `ℕ ]</a>
<a id="30309" class="Symbol">_</a> <a id="30311" class="Symbol">=</a> <a id="30313" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="30319" href="/InferenceC/#30319" class="Function">_</a> <a id="30321" class="Symbol">:</a> <a id="30323" href="/InferenceC/#22957" class="Function">synthesize</a> <a id="30334" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="30336" class="Symbol">(((</a><a id="30339" href="/InferenceC/#10999" class="InductiveConstructor Operator">ƛ</a> <a id="30341" class="String">&quot;x&quot;</a> <a id="30345" href="/InferenceC/#10999" class="InductiveConstructor Operator">⇒</a> <a id="30347" href="/InferenceC/#10837" class="InductiveConstructor Operator">`</a> <a id="30349" class="String">&quot;x&quot;</a> <a id="30353" href="/InferenceC/#11237" class="InductiveConstructor Operator">↑</a><a id="30354" class="Symbol">)</a> <a id="30356" href="/InferenceC/#10930" class="InductiveConstructor Operator">↓</a> <a id="30358" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="30361" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="30363" class="Symbol">(</a><a id="30364" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a> <a id="30367" href="/DeBruijn/#8641" class="InductiveConstructor Operator">⇒</a> <a id="30369" href="/DeBruijn/#8668" class="InductiveConstructor">`ℕ</a><a id="30371" class="Symbol">)))</a> <a id="30375" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="30377" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a> <a id="30380" class="Symbol">_</a>
  <a id="30384" class="Comment">-- error⁻ &quot;inheritance and synthesis conflict&quot; (` &quot;x&quot; ↑) [ `ℕ , `ℕ ⇒ `ℕ ]</a>
<a id="30458" class="Symbol">_</a> <a id="30460" class="Symbol">=</a> <a id="30462" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h2 id="erasure">Erasure</h2>

<p>From the evidence that a decorated term has the correct type it is
easy to extract the corresponding inherently typed term.  We use the
name <code class="highlighter-rouge">DB</code> to refer to the code in
Chapter <a href="/DeBruijn/">DeBruijn</a>.
It is easy to define an <em>erasure</em> function that takes evidence of a
type judgement into the corresponding inherently typed term.</p>

<p>First, we give code to erase a context.</p>
<pre class="Agda"><a id="∥_∥Γ"></a><a id="30916" href="/InferenceC/#30916" class="Function Operator">∥_∥Γ</a> <a id="30921" class="Symbol">:</a> <a id="30923" href="/InferenceC/#10476" class="Datatype">Context</a> <a id="30931" class="Symbol">→</a> <a id="30933" href="/DeBruijn/#8806" class="Datatype">DB.Context</a>
<a id="30944" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="30946" href="/InferenceC/#10498" class="InductiveConstructor">∅</a> <a id="30948" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="30951" class="Symbol">=</a> <a id="30953" href="/DeBruijn/#8828" class="InductiveConstructor">DB.∅</a>
<a id="30958" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="30960" href="/InferenceC/#30960" class="Bound">Γ</a> <a id="30962" href="/InferenceC/#10517" class="InductiveConstructor Operator">,</a> <a id="30964" href="/InferenceC/#30964" class="Bound">x</a> <a id="30966" href="/InferenceC/#10517" class="InductiveConstructor Operator">⦂</a> <a id="30968" href="/InferenceC/#30968" class="Bound">A</a> <a id="30970" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="30973" class="Symbol">=</a> <a id="30975" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="30977" href="/InferenceC/#30960" class="Bound">Γ</a> <a id="30979" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="30982" href="/DeBruijn/#8844" class="InductiveConstructor Operator">DB.,</a> <a id="30987" href="/InferenceC/#30968" class="Bound">A</a></pre>
<p>It simply drops the variable names.</p>

<p>Next, we give code to erase a lookup judgment.</p>
<pre class="Agda"><a id="∥_∥∋"></a><a id="31097" href="/InferenceC/#31097" class="Function Operator">∥_∥∋</a> <a id="31102" class="Symbol">:</a> <a id="31104" class="Symbol">∀</a> <a id="31106" class="Symbol">{</a><a id="31107" href="/InferenceC/#31107" class="Bound">Γ</a> <a id="31109" href="/InferenceC/#31109" class="Bound">x</a> <a id="31111" href="/InferenceC/#31111" class="Bound">A</a><a id="31112" class="Symbol">}</a> <a id="31114" class="Symbol">→</a> <a id="31116" href="/InferenceC/#31107" class="Bound">Γ</a> <a id="31118" href="/InferenceC/#12780" class="Datatype Operator">∋</a> <a id="31120" href="/InferenceC/#31109" class="Bound">x</a> <a id="31122" href="/InferenceC/#12780" class="Datatype Operator">⦂</a> <a id="31124" href="/InferenceC/#31111" class="Bound">A</a> <a id="31126" class="Symbol">→</a> <a id="31128" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="31130" href="/InferenceC/#31107" class="Bound">Γ</a> <a id="31132" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="31135" href="/DeBruijn/#9718" class="Datatype Operator">DB.∋</a> <a id="31140" href="/InferenceC/#31111" class="Bound">A</a>
<a id="31142" href="/InferenceC/#31097" class="Function Operator">∥</a> <a id="31144" href="/InferenceC/#12823" class="InductiveConstructor">Z</a> <a id="31146" href="/InferenceC/#31097" class="Function Operator">∥∋</a> <a id="31149" class="Symbol">=</a>  <a id="31152" href="/DeBruijn/#9754" class="InductiveConstructor">DB.Z</a>
<a id="31157" href="/InferenceC/#31097" class="Function Operator">∥</a> <a id="31159" href="/InferenceC/#12891" class="InductiveConstructor">S</a> <a id="31161" href="/InferenceC/#31161" class="Bound">x≢</a> <a id="31164" href="/InferenceC/#31164" class="Bound">⊢x</a> <a id="31167" href="/InferenceC/#31097" class="Function Operator">∥∋</a> <a id="31170" class="Symbol">=</a>  <a id="31173" href="/DeBruijn/#9802" class="InductiveConstructor Operator">DB.S</a> <a id="31178" href="/InferenceC/#31097" class="Function Operator">∥</a> <a id="31180" href="/InferenceC/#31164" class="Bound">⊢x</a> <a id="31183" href="/InferenceC/#31097" class="Function Operator">∥∋</a></pre>
<p>It just drops the evidence that variable names are distinct.</p>

<p>Finally, we give the code to erase a typing judgement.
Just as there are two mutually recursive typing judgements,
there are two mutually recursive erasure functions.</p>
<pre class="Agda"><a id="∥_∥⁺"></a><a id="31439" href="/InferenceC/#31439" class="Function Operator">∥_∥⁺</a> <a id="31444" class="Symbol">:</a> <a id="31446" class="Symbol">∀</a> <a id="31448" class="Symbol">{</a><a id="31449" href="/InferenceC/#31449" class="Bound">Γ</a> <a id="31451" href="/InferenceC/#31451" class="Bound">M</a> <a id="31453" href="/InferenceC/#31453" class="Bound">A</a><a id="31454" class="Symbol">}</a> <a id="31456" class="Symbol">→</a> <a id="31458" href="/InferenceC/#31449" class="Bound">Γ</a> <a id="31460" href="/InferenceC/#13108" class="Datatype Operator">⊢</a> <a id="31462" href="/InferenceC/#31451" class="Bound">M</a> <a id="31464" href="/InferenceC/#13108" class="Datatype Operator">↑</a> <a id="31466" href="/InferenceC/#31453" class="Bound">A</a> <a id="31468" class="Symbol">→</a> <a id="31470" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="31472" href="/InferenceC/#31449" class="Bound">Γ</a> <a id="31474" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="31477" href="/DeBruijn/#10963" class="Datatype Operator">DB.⊢</a> <a id="31482" href="/InferenceC/#31453" class="Bound">A</a>
<a id="∥_∥⁻"></a><a id="31484" href="/InferenceC/#31484" class="Function Operator">∥_∥⁻</a> <a id="31489" class="Symbol">:</a> <a id="31491" class="Symbol">∀</a> <a id="31493" class="Symbol">{</a><a id="31494" href="/InferenceC/#31494" class="Bound">Γ</a> <a id="31496" href="/InferenceC/#31496" class="Bound">M</a> <a id="31498" href="/InferenceC/#31498" class="Bound">A</a><a id="31499" class="Symbol">}</a> <a id="31501" class="Symbol">→</a> <a id="31503" href="/InferenceC/#31494" class="Bound">Γ</a> <a id="31505" href="/InferenceC/#13150" class="Datatype Operator">⊢</a> <a id="31507" href="/InferenceC/#31496" class="Bound">M</a> <a id="31509" href="/InferenceC/#13150" class="Datatype Operator">↓</a> <a id="31511" href="/InferenceC/#31498" class="Bound">A</a> <a id="31513" class="Symbol">→</a> <a id="31515" href="/InferenceC/#30916" class="Function Operator">∥</a> <a id="31517" href="/InferenceC/#31494" class="Bound">Γ</a> <a id="31519" href="/InferenceC/#30916" class="Function Operator">∥Γ</a> <a id="31522" href="/DeBruijn/#10963" class="Datatype Operator">DB.⊢</a> <a id="31527" href="/InferenceC/#31498" class="Bound">A</a>

<a id="31530" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31532" href="/InferenceC/#13208" class="InductiveConstructor">⊢`</a> <a id="31535" href="/InferenceC/#31535" class="Bound">⊢x</a> <a id="31538" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="31541" class="Symbol">=</a>  <a id="31544" href="/DeBruijn/#10999" class="InductiveConstructor Operator">DB.`</a> <a id="31549" href="/InferenceC/#31097" class="Function Operator">∥</a> <a id="31551" href="/InferenceC/#31535" class="Bound">⊢x</a> <a id="31554" href="/InferenceC/#31097" class="Function Operator">∥∋</a>
<a id="31557" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31559" href="/InferenceC/#31559" class="Bound">⊢L</a> <a id="31562" href="/InferenceC/#13278" class="InductiveConstructor Operator">·</a> <a id="31564" href="/InferenceC/#31564" class="Bound">⊢M</a> <a id="31567" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="31570" class="Symbol">=</a>  <a id="31573" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31575" href="/InferenceC/#31559" class="Bound">⊢L</a> <a id="31578" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="31581" href="/DeBruijn/#11125" class="InductiveConstructor Operator">DB.·</a> <a id="31586" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31588" href="/InferenceC/#31564" class="Bound">⊢M</a> <a id="31591" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>
<a id="31594" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31596" href="/InferenceC/#13377" class="InductiveConstructor">⊢↓</a> <a id="31599" href="/InferenceC/#31599" class="Bound">⊢M</a> <a id="31602" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="31605" class="Symbol">=</a>  <a id="31608" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31610" href="/InferenceC/#31599" class="Bound">⊢M</a> <a id="31613" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>

<a id="31617" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31619" href="/InferenceC/#13473" class="InductiveConstructor">⊢ƛ</a> <a id="31622" href="/InferenceC/#31622" class="Bound">⊢N</a> <a id="31625" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31628" class="Symbol">=</a>  <a id="31631" href="/DeBruijn/#11054" class="InductiveConstructor Operator">DB.ƛ</a> <a id="31636" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31638" href="/InferenceC/#31622" class="Bound">⊢N</a> <a id="31641" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>
<a id="31644" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31646" href="/InferenceC/#13571" class="InductiveConstructor">⊢zero</a> <a id="31652" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31655" class="Symbol">=</a>  <a id="31658" href="/DeBruijn/#11203" class="InductiveConstructor">DB.`zero</a>
<a id="31667" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31669" href="/InferenceC/#13630" class="InductiveConstructor">⊢suc</a> <a id="31674" href="/InferenceC/#31674" class="Bound">⊢M</a> <a id="31677" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31680" class="Symbol">=</a>  <a id="31683" href="/DeBruijn/#11250" class="InductiveConstructor Operator">DB.`suc</a> <a id="31691" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31693" href="/InferenceC/#31674" class="Bound">⊢M</a> <a id="31696" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>
<a id="31699" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31701" href="/InferenceC/#13709" class="InductiveConstructor">⊢case</a> <a id="31707" href="/InferenceC/#31707" class="Bound">⊢L</a> <a id="31710" href="/InferenceC/#31710" class="Bound">⊢M</a> <a id="31713" href="/InferenceC/#31713" class="Bound">⊢N</a> <a id="31716" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31719" class="Symbol">=</a>  <a id="31722" href="/DeBruijn/#11307" class="InductiveConstructor">DB.case</a> <a id="31730" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31732" href="/InferenceC/#31707" class="Bound">⊢L</a> <a id="31735" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="31738" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31740" href="/InferenceC/#31710" class="Bound">⊢M</a> <a id="31743" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31746" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31748" href="/InferenceC/#31713" class="Bound">⊢N</a> <a id="31751" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>
<a id="31754" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31756" href="/InferenceC/#13882" class="InductiveConstructor">⊢μ</a> <a id="31759" href="/InferenceC/#31759" class="Bound">⊢M</a> <a id="31762" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31765" class="Symbol">=</a>  <a id="31768" href="/DeBruijn/#11397" class="InductiveConstructor Operator">DB.μ</a> <a id="31773" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31775" href="/InferenceC/#31759" class="Bound">⊢M</a> <a id="31778" href="/InferenceC/#31484" class="Function Operator">∥⁻</a>
<a id="31781" href="/InferenceC/#31484" class="Function Operator">∥</a> <a id="31783" href="/InferenceC/#13972" class="InductiveConstructor">⊢↑</a> <a id="31786" href="/InferenceC/#31786" class="Bound">⊢M</a> <a id="31789" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="31794" href="/InferenceC/#31484" class="Function Operator">∥⁻</a> <a id="31797" class="Symbol">=</a>  <a id="31800" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="31802" href="/InferenceC/#31786" class="Bound">⊢M</a> <a id="31805" href="/InferenceC/#31439" class="Function Operator">∥⁺</a></pre>
<p>Erasure replaces constructors for each typing judgement
by the corresponding term constructor from <code class="highlighter-rouge">DB</code>.  The
constructors that correspond to switching from synthesized
to inherited or vice versa are dropped.</p>

<p>We confirm that the erasure of the type derivations in
this chapter yield the corresponding inherently typed terms
from the earlier chapter.</p>
<pre class="Agda"><a id="32183" href="/InferenceC/#32183" class="Function">_</a> <a id="32185" class="Symbol">:</a> <a id="32187" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="32189" href="/InferenceC/#27318" class="Function">⊢2+2</a> <a id="32194" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="32197" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32199" href="/DeBruijn/#14239" class="Function">DB.2+2</a>
<a id="32206" class="Symbol">_</a> <a id="32208" class="Symbol">=</a> <a id="32210" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>

<a id="32216" href="/InferenceC/#32216" class="Function">_</a> <a id="32218" class="Symbol">:</a> <a id="32220" href="/InferenceC/#31439" class="Function Operator">∥</a> <a id="32222" href="/InferenceC/#28208" class="Function">⊢2+2ᶜ</a> <a id="32228" href="/InferenceC/#31439" class="Function Operator">∥⁺</a> <a id="32231" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="32233" href="/DeBruijn/#14868" class="Function">DB.2+2ᶜ</a>
<a id="32241" class="Symbol">_</a> <a id="32243" class="Symbol">=</a> <a id="32245" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>Thus, we have confirmed that bidirectional type inference to
convert decorated versions of the lambda terms from
Chapter <a href="/Lambda/">Lambda</a>
to the inherently typed terms of
Chapter <a href="/DeBruijn/">DeBruijn</a>.</p>

<h4 id="exercise-decoration">Exercise (<code class="highlighter-rouge">decoration</code>)</h4>

<p>Extend bidirectional inference to include each of the constructs in
Chapter <a href="/More/">More</a>.</p>

<h2 id="bidirectional-inference-in-agda">Bidirectional inference in Agda</h2>

<p>Agda itself uses bidirectional inference.  This explains why
constructors can be overloaded while other defined names cannot — here
by <em>overloaded</em> we mean that the same name can be used for
constructors of different types.  Constructors are typed by
inheritance, and so the name is available when resolving the
constructor, whereas variables are typed by synthesis, and so each
variable must have a unique type.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>↓  U+2193:  DOWNWARDS ARROW (\d)
↑  U+2191:  UPWARDS ARROW (\u)
←  U+2190:  LEFTWARDS ARROW (\l)
∥  U+2225:  PARALLEL TO (\||)
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li><li><a href="https://www.twitter.com/philipwadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">philipwadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div></div>

</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
